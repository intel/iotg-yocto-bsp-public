diff -x .git -x .gitignore -Naur intel-driver/gms-integration isg_gms-intel-va-driver/gms-integration
--- intel-driver/gms-integration	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-intel-va-driver/gms-integration	2016-08-08 02:32:08.998326262 +0800
@@ -0,0 +1,5 @@
+###
+### GMS integration
+###
+upstream_v1.7 396224348ae47f3093e79dc84a7d4f1f1513ba55
+	libva-intel-driver 1.7.1
diff -x .git -x .gitignore -Naur intel-driver/src/gen6_mfc_common.c isg_gms-intel-va-driver/src/gen6_mfc_common.c
--- intel-driver/src/gen6_mfc_common.c	2016-08-08 02:32:16.154448256 +0800
+++ isg_gms-intel-va-driver/src/gen6_mfc_common.c	2016-08-08 02:32:08.998326262 +0800
@@ -790,6 +790,11 @@
 
     assert(qp <= QP_MAX); 
     lambda = intel_lambda_qp(qp);
+
+    m_cost = lambda;
+    vme_state_message[MODE_CHROMA_INTRA] = intel_format_lutvalue(m_cost, 0x8f);
+    vme_state_message[MODE_REFID_COST] = intel_format_lutvalue(m_cost, 0x8f);
+
     if (slice_type == SLICE_TYPE_I) {
         vme_state_message[MODE_INTRA_16X16] = 0;
         m_cost = lambda * 4;
diff -x .git -x .gitignore -Naur intel-driver/src/gen75_vpp_vebox.c isg_gms-intel-va-driver/src/gen75_vpp_vebox.c
--- intel-driver/src/gen75_vpp_vebox.c	2016-08-08 02:32:16.154448256 +0800
+++ isg_gms-intel-va-driver/src/gen75_vpp_vebox.c	2016-08-08 02:32:09.002326330 +0800
@@ -923,6 +923,7 @@
         dri_bo *iecp_bo = proc_ctx->iecp_state_table.bo;
         dri_bo_map(iecp_bo, 1);
         proc_ctx->iecp_state_table.ptr = iecp_bo->virtual;
+        memset(proc_ctx->iecp_state_table.ptr, 0, 97 * 4);
 
         hsw_veb_iecp_std_table(ctx, proc_ctx);
         hsw_veb_iecp_ace_table(ctx, proc_ctx);
@@ -1378,11 +1379,11 @@
 
     proc_ctx->format_convert_flags = 0;
 
-    proc_ctx->width_input   = obj_surf_input->orig_width;
-    proc_ctx->height_input  = obj_surf_input->orig_height;
-    proc_ctx->width_output  = obj_surf_output->orig_width;
-    proc_ctx->height_output = obj_surf_output->orig_height;
-   
+    proc_ctx->width_input   = proc_ctx->pipeline_param->surface_region->width;
+    proc_ctx->height_input  = proc_ctx->pipeline_param->surface_region->height;
+    proc_ctx->width_output  = proc_ctx->pipeline_param->output_region->width;
+    proc_ctx->height_output = proc_ctx->pipeline_param->output_region->height;
+
     /* only partial frame is not supported to be processed */
     /*
     assert(proc_ctx->width_input   == proc_ctx->pipeline_param->surface_region->width);
@@ -1500,16 +1501,18 @@
      return 0;
 }
 
-int hsw_veb_post_format_convert(VADriverContextP ctx,
+VAStatus
+hsw_veb_post_format_convert(VADriverContextP ctx,
                            struct intel_vebox_context *proc_ctx)
 {
     struct object_surface *obj_surface = NULL;
+    VAStatus va_status = VA_STATUS_SUCCESS;
     
     obj_surface = proc_ctx->frame_store[proc_ctx->current_output].obj_surface;
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {
         /* copy the saved frame in the second call */
-        vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
+        va_status = vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
     } else if(!(proc_ctx->format_convert_flags & POST_FORMAT_CONVERT) &&
        !(proc_ctx->format_convert_flags & POST_SCALING_CONVERT)){
         /* Output surface format is covered by vebox pipeline and 
@@ -1518,7 +1521,7 @@
     } else if ((proc_ctx->format_convert_flags & POST_FORMAT_CONVERT) &&
                !(proc_ctx->format_convert_flags & POST_SCALING_CONVERT)){
        /* convert and copy NV12 to YV12/IMC3/IMC2/RGBA output*/
-        vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
+        va_status = vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
 
     } else if(proc_ctx->format_convert_flags & POST_SCALING_CONVERT) {
         VAProcPipelineParameterBuffer * const pipe = proc_ctx->pipeline_param;
@@ -1532,20 +1535,10 @@
         /* second step: color format convert and copy to output */
         obj_surface = proc_ctx->surface_output_object;
 
-        if(obj_surface->fourcc ==  VA_FOURCC_NV12 ||
-           obj_surface->fourcc ==  VA_FOURCC_YV12 ||
-           obj_surface->fourcc ==  VA_FOURCC_I420 ||
-           obj_surface->fourcc ==  VA_FOURCC_YUY2 ||
-           obj_surface->fourcc ==  VA_FOURCC_IMC1 ||
-           obj_surface->fourcc ==  VA_FOURCC_IMC3 ||
-           obj_surface->fourcc ==  VA_FOURCC_RGBA) {
-            vpp_surface_convert(ctx, proc_ctx->surface_output_scaled_object, obj_surface);
-       }else {
-           assert(0); 
-       }
+	va_status = vpp_surface_convert(ctx, proc_ctx->surface_output_scaled_object, obj_surface);
    }
 
-    return 0;
+    return va_status;
 }
 
 static VAStatus
@@ -1714,9 +1707,9 @@
         intel_batchbuffer_flush(proc_ctx->batch);
     }
 
-    hsw_veb_post_format_convert(ctx, proc_ctx);
+    status = hsw_veb_post_format_convert(ctx, proc_ctx);
      
-    return VA_STATUS_SUCCESS;
+    return status;
 }
 
 void gen75_vebox_context_destroy(VADriverContextP ctx, 
@@ -1944,9 +1937,9 @@
         intel_batchbuffer_flush(proc_ctx->batch);
     }
 
-    hsw_veb_post_format_convert(ctx, proc_ctx);
+    status = hsw_veb_post_format_convert(ctx, proc_ctx);
      
-    return VA_STATUS_SUCCESS;
+    return status;
 }
 
 
@@ -2204,6 +2197,7 @@
         dri_bo *iecp_bo = proc_ctx->iecp_state_table.bo;
         dri_bo_map(iecp_bo, 1);
         proc_ctx->iecp_state_table.ptr = iecp_bo->virtual;
+        memset(proc_ctx->iecp_state_table.ptr, 0, 90 * 4);
 
         hsw_veb_iecp_std_table(ctx, proc_ctx);
         hsw_veb_iecp_ace_table(ctx, proc_ctx);
@@ -2412,7 +2406,7 @@
         intel_batchbuffer_flush(proc_ctx->batch);
     }
 
-    hsw_veb_post_format_convert(ctx, proc_ctx);
+    status = hsw_veb_post_format_convert(ctx, proc_ctx);
 
-    return VA_STATUS_SUCCESS;
+    return status;
 }
diff -x .git -x .gitignore -Naur intel-driver/src/gen8_mfc.c isg_gms-intel-va-driver/src/gen8_mfc.c
--- intel-driver/src/gen8_mfc.c	2016-08-08 02:32:16.154448256 +0800
+++ isg_gms-intel-va-driver/src/gen8_mfc.c	2016-08-08 02:32:09.006326399 +0800
@@ -49,7 +49,7 @@
 #define SURFACE_STATE_OFFSET(index)             (SURFACE_STATE_PADDED_SIZE * index)
 #define BINDING_TABLE_OFFSET(index)             (SURFACE_STATE_OFFSET(MAX_MEDIA_SURFACES_GEN6) + sizeof(unsigned int) * index)
 
-#define MFC_SOFTWARE_HASWELL	1
+#define MFC_SOFTWARE_BATCH      0
 
 #define B0_STEP_REV		2
 #define IS_STEPPING_BPLUS(i965)	((i965->intel.revision) >= B0_STEP_REV)
@@ -101,32 +101,35 @@
     MFX_HUFFTABLE_ID_UV
 };
 
-static const uint32_t gen8_mfc_batchbuffer_avc_intra[][4] = {
-#include "shaders/utils/mfc_batchbuffer_avc_intra.g7b"
+static const uint32_t gen8_mfc_batchbuffer_avc[][4] = {
+#include "shaders/utils/mfc_batchbuffer_hsw.g8b"
 };
 
-static const uint32_t gen8_mfc_batchbuffer_avc_inter[][4] = {
-#include "shaders/utils/mfc_batchbuffer_avc_inter.g7b"
+static const uint32_t gen9_mfc_batchbuffer_avc[][4] = {
+#include "shaders/utils/mfc_batchbuffer_hsw.g9b"
 };
 
 static struct i965_kernel gen8_mfc_kernels[] = {
     {
         "MFC AVC INTRA BATCHBUFFER ",
         MFC_BATCHBUFFER_AVC_INTRA,
-        gen8_mfc_batchbuffer_avc_intra,
-        sizeof(gen8_mfc_batchbuffer_avc_intra),
+        gen8_mfc_batchbuffer_avc,
+        sizeof(gen8_mfc_batchbuffer_avc),
         NULL
     },
+};
 
+static struct i965_kernel gen9_mfc_kernels[] = {
     {
-        "MFC AVC INTER BATCHBUFFER ",
-        MFC_BATCHBUFFER_AVC_INTER,
-        gen8_mfc_batchbuffer_avc_inter,
-        sizeof(gen8_mfc_batchbuffer_avc_inter),
+        "MFC AVC INTRA BATCHBUFFER ",
+        MFC_BATCHBUFFER_AVC_INTRA,
+        gen9_mfc_batchbuffer_avc,
+        sizeof(gen9_mfc_batchbuffer_avc),
         NULL
     },
 };
 
+
 #define		INTER_MODE_MASK		0x03
 #define		INTER_8X8		0x03
 #define		INTER_16X8		0x01
@@ -570,7 +573,7 @@
     mfc_context->aux_batchbuffer_surface.num_blocks = mfc_context->aux_batchbuffer->size / 16;
     mfc_context->aux_batchbuffer_surface.size_block = 16;
 
-    i965_gpe_context_init(ctx, &mfc_context->gpe_context);
+    gen8_gpe_context_init(ctx, &mfc_context->gpe_context);
 }
 
 static void
@@ -930,8 +933,13 @@
     ADVANCE_BCS_BATCH(batch);
 }
 
+#define    AVC_INTRA_RDO_OFFSET    4
+#define    AVC_INTER_RDO_OFFSET    10
+#define    AVC_INTER_MSG_OFFSET    8
+#define    AVC_INTER_MV_OFFSET     48
+#define    AVC_RDO_MASK            0xFFFF
 
-#ifdef MFC_SOFTWARE_HASWELL
+#if MFC_SOFTWARE_BATCH
 
 static int
 gen8_mfc_avc_pak_object_intra(VADriverContextP ctx, int x, int y, int end_mb,
@@ -1082,12 +1090,6 @@
     return len_in_dwords;
 }
 
-#define		AVC_INTRA_RDO_OFFSET	4
-#define		AVC_INTER_RDO_OFFSET	10
-#define		AVC_INTER_MSG_OFFSET	8	
-#define		AVC_INTER_MV_OFFSET		48
-#define		AVC_RDO_MASK		0xFFFF
-
 static void 
 gen8_mfc_avc_pipeline_slice_programing(VADriverContextP ctx,
                                        struct encode_state *encode_state,
@@ -1221,7 +1223,6 @@
 gen8_mfc_batchbuffer_surfaces_input(VADriverContextP ctx,
                                     struct encode_state *encode_state,
                                     struct intel_encoder_context *encoder_context)
-
 {
     struct gen6_vme_context *vme_context = encoder_context->vme_context;
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
@@ -1232,35 +1233,18 @@
                                      &vme_context->vme_output,
                                      BINDING_TABLE_OFFSET(BIND_IDX_VME_OUTPUT),
                                      SURFACE_STATE_OFFSET(BIND_IDX_VME_OUTPUT));
-    assert(mfc_context->aux_batchbuffer_surface.bo);
-    mfc_context->buffer_suface_setup(ctx,
-                                     &mfc_context->gpe_context,
-                                     &mfc_context->aux_batchbuffer_surface,
-                                     BINDING_TABLE_OFFSET(BIND_IDX_MFC_SLICE_HEADER),
-                                     SURFACE_STATE_OFFSET(BIND_IDX_MFC_SLICE_HEADER));
 }
 
 static void
 gen8_mfc_batchbuffer_surfaces_output(VADriverContextP ctx,
                                      struct encode_state *encode_state,
                                      struct intel_encoder_context *encoder_context)
-
 {
-    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
-    VAEncSequenceParameterBufferH264 *pSequenceParameter = (VAEncSequenceParameterBufferH264 *)encode_state->seq_param_ext->buffer;
-    int width_in_mbs = pSequenceParameter->picture_width_in_mbs;
-    int height_in_mbs = pSequenceParameter->picture_height_in_mbs;
-    mfc_context->mfc_batchbuffer_surface.num_blocks = width_in_mbs * height_in_mbs + encode_state->num_slice_params_ext * 8 + 1;
-    mfc_context->mfc_batchbuffer_surface.size_block = 16 * CMD_LEN_IN_OWORD; /* 3 OWORDs */
-    mfc_context->mfc_batchbuffer_surface.pitch = 16;
-    mfc_context->mfc_batchbuffer_surface.bo = dri_bo_alloc(i965->intel.bufmgr, 
-                                                           "MFC batchbuffer",
-                                                           mfc_context->mfc_batchbuffer_surface.num_blocks * mfc_context->mfc_batchbuffer_surface.size_block,
-                                                           0x1000);
+    assert(mfc_context->aux_batchbuffer_surface.bo);
     mfc_context->buffer_suface_setup(ctx,
                                      &mfc_context->gpe_context,
-                                     &mfc_context->mfc_batchbuffer_surface,
+                                     &mfc_context->aux_batchbuffer_surface,
                                      BINDING_TABLE_OFFSET(BIND_IDX_MFC_BATCHBUFFER),
                                      SURFACE_STATE_OFFSET(BIND_IDX_MFC_BATCHBUFFER));
 }
@@ -1280,41 +1264,39 @@
                                 struct intel_encoder_context *encoder_context)
 {
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
-    struct gen6_interface_descriptor_data *desc;   
+    struct gen8_interface_descriptor_data *desc;
     int i;
     dri_bo *bo;
+    unsigned char *desc_ptr;
 
-    bo = mfc_context->gpe_context.idrt.bo;
+    bo = mfc_context->gpe_context.dynamic_state.bo;
     dri_bo_map(bo, 1);
     assert(bo->virtual);
-    desc = bo->virtual;
+    desc_ptr = (unsigned char *)bo->virtual + mfc_context->gpe_context.idrt_offset;
+
+    desc = (struct gen8_interface_descriptor_data *)desc_ptr;
 
     for (i = 0; i < mfc_context->gpe_context.num_kernels; i++) {
         struct i965_kernel *kernel;
-
         kernel = &mfc_context->gpe_context.kernels[i];
         assert(sizeof(*desc) == 32);
-
         /*Setup the descritor table*/
         memset(desc, 0, sizeof(*desc));
-        desc->desc0.kernel_start_pointer = (kernel->bo->offset >> 6);
-        desc->desc2.sampler_count = 0;
-        desc->desc2.sampler_state_pointer = 0;
-        desc->desc3.binding_table_entry_count = 2;
-        desc->desc3.binding_table_pointer = (BINDING_TABLE_OFFSET(0) >> 5);
-        desc->desc4.constant_urb_entry_read_offset = 0;
-        desc->desc4.constant_urb_entry_read_length = 4;
+        desc->desc0.kernel_start_pointer = kernel->kernel_offset >> 6;
+        desc->desc3.sampler_count = 0;
+        desc->desc3.sampler_state_pointer = 0;
+        desc->desc4.binding_table_entry_count = 1;
+        desc->desc4.binding_table_pointer = (BINDING_TABLE_OFFSET(0) >> 5);
+        desc->desc5.constant_urb_entry_read_offset = 0;
+        desc->desc5.constant_urb_entry_read_length = 4;
+
  		
-        /*kernel start*/
-        dri_bo_emit_reloc(bo,	
-                          I915_GEM_DOMAIN_INSTRUCTION, 0,
-                          0,
-                          i * sizeof(*desc) + offsetof(struct gen6_interface_descriptor_data, desc0),
-                          kernel->bo);
         desc++;
     }
 
     dri_bo_unmap(bo);
+
+    return;
 }
 
 static void
@@ -1327,147 +1309,129 @@
     (void)mfc_context;
 }
 
+#define AVC_PAK_LEN_IN_BYTE	48
+#define AVC_PAK_LEN_IN_OWORD	3
+
 static void
 gen8_mfc_batchbuffer_emit_object_command(struct intel_batchbuffer *batch,
-                                         int index,
-                                         int head_offset,
-                                         int batchbuffer_offset,
-                                         int head_size,
-                                         int tail_size,
-                                         int number_mb_cmds,
-                                         int first_object,
-                                         int last_object,
-                                         int last_slice,
-                                         int mb_x,
-                                         int mb_y,
-                                         int width_in_mbs,
-                                         int qp)
+                                          uint32_t intra_flag,
+                                          int head_offset,
+                                          int number_mb_cmds,
+                                          int slice_end_x,
+                                          int slice_end_y,
+                                          int mb_x,
+                                          int mb_y,
+                                          int width_in_mbs,
+                                          int qp,
+					  uint32_t fwd_ref,
+					  uint32_t bwd_ref)
 {
-    BEGIN_BATCH(batch, 12);
+    uint32_t temp_value;
+    BEGIN_BATCH(batch, 14);
     
-    OUT_BATCH(batch, CMD_MEDIA_OBJECT | (12 - 2));
-    OUT_BATCH(batch, index);
+    OUT_BATCH(batch, CMD_MEDIA_OBJECT | (14 - 2));
+    OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
     OUT_BATCH(batch, 0);
    
     /*inline data */
-    OUT_BATCH(batch, head_offset);
-    OUT_BATCH(batch, batchbuffer_offset);
-    OUT_BATCH(batch, 
-              head_size << 16 |
-              tail_size);
-    OUT_BATCH(batch,
-              number_mb_cmds << 16 |
-              first_object << 2 |
-              last_object << 1 |
-              last_slice);
-    OUT_BATCH(batch,
-              mb_y << 8 |
-              mb_x);
+    OUT_BATCH(batch, head_offset / 16);
+    OUT_BATCH(batch, (intra_flag) | (qp << 16));
+    temp_value = (mb_x | (mb_y << 8) | (width_in_mbs << 16));
+    OUT_BATCH(batch, temp_value);
+
+    OUT_BATCH(batch, number_mb_cmds);
+
     OUT_BATCH(batch,
-              qp << 16 |
-              width_in_mbs);
+              ((slice_end_y << 8) | (slice_end_x)));
+    OUT_BATCH(batch, fwd_ref);
+    OUT_BATCH(batch, bwd_ref);
+
+    OUT_BATCH(batch, MI_NOOP);
 
     ADVANCE_BATCH(batch);
 }
 
 static void
 gen8_mfc_avc_batchbuffer_slice_command(VADriverContextP ctx,
-                                       struct intel_encoder_context *encoder_context,
-                                       VAEncSliceParameterBufferH264 *slice_param,
-                                       int head_offset,
-                                       unsigned short head_size,
-                                       unsigned short tail_size,
-                                       int batchbuffer_offset,
-                                       int qp,
-                                       int last_slice)
+                                        struct intel_encoder_context *encoder_context,
+                                        VAEncSliceParameterBufferH264 *slice_param,
+                                        int head_offset,
+                                        int qp,
+                                        int last_slice)
 {
     struct intel_batchbuffer *batch = encoder_context->base.batch;
+    struct gen6_vme_context *vme_context = encoder_context->vme_context;
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     int width_in_mbs = (mfc_context->surface_state.width + 15) / 16;
     int total_mbs = slice_param->num_macroblocks;
+    int slice_type = intel_avc_enc_slice_type_fixup(slice_param->slice_type);
     int number_mb_cmds = 128;
-    int starting_mb = 0;
-    int last_object = 0;
-    int first_object = 1;
-    int i;
+    int starting_offset = 0;
     int mb_x, mb_y;
-    int index = (slice_param->slice_type == SLICE_TYPE_I) ? MFC_BATCHBUFFER_AVC_INTRA : MFC_BATCHBUFFER_AVC_INTER;
+    int last_mb, slice_end_x, slice_end_y;
+    int remaining_mb = total_mbs;
+    uint32_t fwd_ref , bwd_ref, mb_flag;
+
+    last_mb = slice_param->macroblock_address + total_mbs - 1;
+    slice_end_x = last_mb % width_in_mbs;
+    slice_end_y = last_mb / width_in_mbs;
 
-    for (i = 0; i < total_mbs / number_mb_cmds; i++) {
-        last_object = (total_mbs - starting_mb) == number_mb_cmds;
-        mb_x = (slice_param->macroblock_address + starting_mb) % width_in_mbs;
-        mb_y = (slice_param->macroblock_address + starting_mb) / width_in_mbs;
-        assert(mb_x <= 255 && mb_y <= 255);
+    if (slice_type == SLICE_TYPE_I) {
+	fwd_ref = 0;
+	bwd_ref = 0;
+	mb_flag = 1;
+    } else {
+	fwd_ref = vme_context->ref_index_in_mb[0];
+	bwd_ref = vme_context->ref_index_in_mb[1];
+	mb_flag = 0;
+    }
 
-        starting_mb += number_mb_cmds;
+    if (width_in_mbs >= 100) {
+	number_mb_cmds = width_in_mbs / 5;
+    } else if (width_in_mbs >= 80) {
+	number_mb_cmds = width_in_mbs / 4;
+    } else if (width_in_mbs >= 60) {
+	number_mb_cmds = width_in_mbs / 3;
+    } else if (width_in_mbs >= 40) {
+	number_mb_cmds = width_in_mbs / 2;
+    } else {
+	number_mb_cmds = width_in_mbs;
+    }
 
-        gen8_mfc_batchbuffer_emit_object_command(batch,
-                                                 index,
-                                                 head_offset,
-                                                 batchbuffer_offset,
-                                                 head_size,
-                                                 tail_size,
-                                                 number_mb_cmds,
-                                                 first_object,
-                                                 last_object,
-                                                 last_slice,
-                                                 mb_x,
-                                                 mb_y,
-                                                 width_in_mbs,
-                                                 qp);
-
-        if (first_object) {
-            head_offset += head_size;
-            batchbuffer_offset += head_size;
-        }
-
-        if (last_object) {
-            head_offset += tail_size;
-            batchbuffer_offset += tail_size;
-        }
-
-        batchbuffer_offset += number_mb_cmds * CMD_LEN_IN_OWORD;
-
-        first_object = 0;
-    }
-
-    if (!last_object) {
-        last_object = 1;
-        number_mb_cmds = total_mbs % number_mb_cmds;
-        mb_x = (slice_param->macroblock_address + starting_mb) % width_in_mbs;
-        mb_y = (slice_param->macroblock_address + starting_mb) / width_in_mbs;
-        assert(mb_x <= 255 && mb_y <= 255);
-        starting_mb += number_mb_cmds;
+    do {
+	if (number_mb_cmds >= remaining_mb) {
+		number_mb_cmds = remaining_mb;
+	}
+	mb_x = (slice_param->macroblock_address + starting_offset) % width_in_mbs;
+	mb_y = (slice_param->macroblock_address + starting_offset) / width_in_mbs;
 
         gen8_mfc_batchbuffer_emit_object_command(batch,
-                                                 index,
-                                                 head_offset,
-                                                 batchbuffer_offset,
-                                                 head_size,
-                                                 tail_size,
-                                                 number_mb_cmds,
-                                                 first_object,
-                                                 last_object,
-                                                 last_slice,
-                                                 mb_x,
-                                                 mb_y,
-                                                 width_in_mbs,
-                                                 qp);
-    }
+						  mb_flag,
+                                                  head_offset,
+                                                  number_mb_cmds,
+						  slice_end_x,
+						  slice_end_y,
+                                                  mb_x,
+                                                  mb_y,
+                                                  width_in_mbs,
+                                                  qp,
+						  fwd_ref,
+						  bwd_ref);
+
+	head_offset += (number_mb_cmds * AVC_PAK_LEN_IN_BYTE);
+	remaining_mb -= number_mb_cmds;
+	starting_offset += number_mb_cmds;
+    } while (remaining_mb > 0);
 }
-                          
-/*
- * return size in Owords (16bytes)
- */         
-static int
+
+static void
 gen8_mfc_avc_batchbuffer_slice(VADriverContextP ctx,
-                               struct encode_state *encode_state,
-                               struct intel_encoder_context *encoder_context,
-                               int slice_index,
-                               int batchbuffer_offset)
+                                struct encode_state *encode_state,
+                                struct intel_encoder_context *encoder_context,
+                                int slice_index)
 {
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     struct intel_batchbuffer *slice_batch = mfc_context->aux_batchbuffer;
@@ -1481,8 +1445,6 @@
     unsigned int rate_control_mode = encoder_context->rate_control_mode;
     unsigned int tail_data[] = { 0x0, 0x0 };
     long head_offset;
-    int old_used = intel_batchbuffer_used_size(slice_batch), used;
-    unsigned short head_size, tail_size;
     int slice_type = intel_avc_enc_slice_type_fixup(pSliceParameter->slice_type);
     int qp_slice;
 
@@ -1501,15 +1463,14 @@
     assert(pPicParameter->pic_init_qp >= 0 && pPicParameter->pic_init_qp < 52);
     assert(qp >= 0 && qp < 52);
 
-    head_offset = old_used / 16;
     gen8_mfc_avc_slice_state(ctx,
-                             pPicParameter,
-                             pSliceParameter,
-                             encode_state,
-                             encoder_context,
-                             (rate_control_mode == VA_RC_CBR),
-                             qp_slice,
-                             slice_batch);
+                              pPicParameter,
+                              pSliceParameter,
+                              encode_state,
+                              encoder_context,
+                              (rate_control_mode == VA_RC_CBR),
+                              qp_slice,
+                              slice_batch);
 
     if (slice_index == 0)
         intel_mfc_avc_pipeline_header_programing(ctx, encode_state, encoder_context, slice_batch);
@@ -1517,11 +1478,20 @@
     intel_avc_slice_insert_packed_data(ctx, encode_state, encoder_context, slice_index, slice_batch);
 
     intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
-    used = intel_batchbuffer_used_size(slice_batch);
-    head_size = (used - old_used) / 16;
-    old_used = used;
+    head_offset = intel_batchbuffer_used_size(slice_batch);
+
+    slice_batch->ptr += pSliceParameter->num_macroblocks * AVC_PAK_LEN_IN_BYTE;
+
+    gen8_mfc_avc_batchbuffer_slice_command(ctx,
+                                            encoder_context,
+                                            pSliceParameter,
+                                            head_offset,
+                                            qp,
+                                            last_slice);
+
 
-    /* tail */
+    /* Aligned for tail */
+    intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
     if (last_slice) {    
         mfc_context->insert_object(ctx,
                                    encoder_context,
@@ -1546,22 +1516,7 @@
                                    slice_batch);
     }
 
-    intel_batchbuffer_align(slice_batch, 16); /* aligned by an Oword */
-    used = intel_batchbuffer_used_size(slice_batch);
-    tail_size = (used - old_used) / 16;
-
-   
-    gen8_mfc_avc_batchbuffer_slice_command(ctx,
-                                           encoder_context,
-                                           pSliceParameter,
-                                           head_offset,
-                                           head_size,
-                                           tail_size,
-                                           batchbuffer_offset,
-                                           qp,
-                                           last_slice);
-
-    return head_size + tail_size + pSliceParameter->num_macroblocks * CMD_LEN_IN_OWORD;
+    return;
 }
 
 static void
@@ -1569,19 +1524,41 @@
                                   struct encode_state *encode_state,
                                   struct intel_encoder_context *encoder_context)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
     struct intel_batchbuffer *batch = encoder_context->base.batch;
-    int i, size, offset = 0;
-    intel_batchbuffer_start_atomic(batch, 0x4000); 
-    gen6_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
+    int i;
+
+    intel_batchbuffer_start_atomic(batch, 0x4000);
+
+    if (IS_GEN9(i965->intel.device_info))
+        gen9_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
+    else
+        gen8_gpe_pipeline_setup(ctx, &mfc_context->gpe_context, batch);
 
     for ( i = 0; i < encode_state->num_slice_params_ext; i++) {
-        size = gen8_mfc_avc_batchbuffer_slice(ctx, encode_state, encoder_context, i, offset);
-        offset += size;
+        gen8_mfc_avc_batchbuffer_slice(ctx, encode_state, encoder_context, i);
+    }
+    {
+        struct intel_batchbuffer *slice_batch = mfc_context->aux_batchbuffer;
+
+        intel_batchbuffer_align(slice_batch, 8);
+        BEGIN_BCS_BATCH(slice_batch, 2);
+        OUT_BCS_BATCH(slice_batch, 0);
+        OUT_BCS_BATCH(slice_batch, MI_BATCH_BUFFER_END);
+        ADVANCE_BCS_BATCH(slice_batch);
+
+        BEGIN_BATCH(batch, 2);
+        OUT_BATCH(batch, CMD_MEDIA_STATE_FLUSH);
+        OUT_BATCH(batch, 0);
+        ADVANCE_BATCH(batch);
     }
 
     intel_batchbuffer_end_atomic(batch);
     intel_batchbuffer_flush(batch);
+
+    if (IS_GEN9(i965->intel.device_info))
+        gen9_gpe_pipeline_end(ctx, &mfc_context->gpe_context, batch);
 }
 
 static void
@@ -1602,10 +1579,10 @@
 {
     struct gen6_mfc_context *mfc_context = encoder_context->mfc_context;
 
+    dri_bo_reference(mfc_context->aux_batchbuffer_surface.bo);
     gen8_mfc_build_avc_batchbuffer(ctx, encode_state, encoder_context);
-    dri_bo_reference(mfc_context->mfc_batchbuffer_surface.bo);
 
-    return mfc_context->mfc_batchbuffer_surface.bo;
+    return mfc_context->aux_batchbuffer_surface.bo;
 }
 
 #endif
@@ -1624,7 +1601,7 @@
         return; 
     }
 
-#ifdef MFC_SOFTWARE_HASWELL
+#if MFC_SOFTWARE_BATCH
     slice_batch_bo = gen8_mfc_avc_software_batchbuffer(ctx, encode_state, encoder_context);
 #else
     slice_batch_bo = gen8_mfc_avc_hardware_batchbuffer(ctx, encode_state, encoder_context);
@@ -3712,8 +3689,10 @@
     dri_bo_unreference(mfc_context->aux_batchbuffer_surface.bo);
     mfc_context->aux_batchbuffer_surface.bo = NULL;
 
-    if (mfc_context->aux_batchbuffer)
+    if (mfc_context->aux_batchbuffer) {
         intel_batchbuffer_free(mfc_context->aux_batchbuffer);
+        mfc_context->aux_batchbuffer = NULL;
+    }
 
     mfc_context->aux_batchbuffer = intel_batchbuffer_new(&i965->intel, I915_EXEC_BSD, slice_batchbuffer_size);
     mfc_context->aux_batchbuffer_surface.bo = mfc_context->aux_batchbuffer->buffer;
@@ -3722,7 +3701,7 @@
     mfc_context->aux_batchbuffer_surface.num_blocks = mfc_context->aux_batchbuffer->size / 16;
     mfc_context->aux_batchbuffer_surface.size_block = 16;
 
-    i965_gpe_context_init(ctx, &mfc_context->gpe_context);
+    gen8_gpe_context_init(ctx, &mfc_context->gpe_context);
 
     /* alloc vp8 encoding buffers*/
     dri_bo_unreference(mfc_context->vp8_state.frame_header_bo);
@@ -4489,7 +4468,7 @@
         mfc_context->reference_surfaces[i].bo = NULL;  
     }
 
-    i965_gpe_context_destroy(&mfc_context->gpe_context);
+    gen8_gpe_context_destroy(&mfc_context->gpe_context);
 
     dri_bo_unreference(mfc_context->mfc_batchbuffer_surface.bo);
     mfc_context->mfc_batchbuffer_surface.bo = NULL;
@@ -4567,14 +4546,15 @@
 
 Bool gen8_mfc_context_init(VADriverContextP ctx, struct intel_encoder_context *encoder_context)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen6_mfc_context *mfc_context = calloc(1, sizeof(struct gen6_mfc_context));
+
     assert(mfc_context);
     mfc_context->gpe_context.surface_state_binding_table.length = (SURFACE_STATE_PADDED_SIZE + sizeof(unsigned int)) * MAX_MEDIA_SURFACES_GEN6;
 
-    mfc_context->gpe_context.idrt.max_entries = MAX_GPE_KERNELS;
-    mfc_context->gpe_context.idrt.entry_size = sizeof(struct gen6_interface_descriptor_data);
-
-    mfc_context->gpe_context.curbe.length = 32 * 4;
+    mfc_context->gpe_context.idrt_size = sizeof(struct gen8_interface_descriptor_data) * MAX_INTERFACE_DESC_GEN6;
+    mfc_context->gpe_context.curbe_size = 32 * 4;
+    mfc_context->gpe_context.sampler_size = 0;
 
     mfc_context->gpe_context.vfe_state.max_num_threads = 60 - 1;
     mfc_context->gpe_context.vfe_state.num_urb_entries = 16;
@@ -4582,10 +4562,17 @@
     mfc_context->gpe_context.vfe_state.urb_entry_size = 59 - 1;
     mfc_context->gpe_context.vfe_state.curbe_allocation_size = 37 - 1;
 
-    i965_gpe_load_kernels(ctx,
+    if (IS_GEN9(i965->intel.device_info)) {
+        gen8_gpe_load_kernels(ctx,
+                          &mfc_context->gpe_context,
+                          gen9_mfc_kernels,
+                          1);
+    } else {
+        gen8_gpe_load_kernels(ctx,
                           &mfc_context->gpe_context,
                           gen8_mfc_kernels,
-                          NUM_MFC_KERNEL);
+                          1);
+    }
 
     mfc_context->pipe_mode_select = gen8_mfc_pipe_mode_select;
     mfc_context->set_surface_state = gen8_mfc_surface_state;
diff -x .git -x .gitignore -Naur intel-driver/src/gen8_post_processing.c isg_gms-intel-va-driver/src/gen8_post_processing.c
--- intel-driver/src/gen8_post_processing.c	2016-08-08 02:32:16.154448256 +0800
+++ isg_gms-intel-va-driver/src/gen8_post_processing.c	2016-08-08 02:32:09.006326399 +0800
@@ -380,6 +380,7 @@
                           int width, int height, int pitch, int format,
 			  int index, int is_target)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen8_surface_state *ss;
     dri_bo *ss_bo;
     unsigned int tiling;
@@ -393,6 +394,10 @@
     assert(ss_bo->virtual);
     ss = (struct gen8_surface_state *)((char *)ss_bo->virtual + SURFACE_STATE_OFFSET(index));
     memset(ss, 0, sizeof(*ss));
+
+    if (IS_GEN9(i965->intel.device_info))
+        ss->ss1.surface_mocs = GEN9_CACHE_PTE;
+
     ss->ss0.surface_type = I965_SURFACE_2D;
     ss->ss0.surface_format = format;
     ss->ss8.base_addr = surf_bo->offset + surf_bo_offset;
@@ -424,6 +429,7 @@
                            int format, int interleave_chroma,
                            int index)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct gen8_surface_state2 *ss2;
     dri_bo *ss2_bo;
     unsigned int tiling;
@@ -437,6 +443,10 @@
     assert(ss2_bo->virtual);
     ss2 = (struct gen8_surface_state2 *)((char *)ss2_bo->virtual + SURFACE_STATE_OFFSET(index));
     memset(ss2, 0, sizeof(*ss2));
+
+    if (IS_GEN9(i965->intel.device_info))
+        ss2->ss5.surface_object_mocs = GEN9_CACHE_PTE;
+
     ss2->ss6.base_addr = surf_bo->offset + surf_bo_offset;
     ss2->ss1.cbcr_pixel_offset_v_direction = 0;
     ss2->ss1.width = width - 1;
diff -x .git -x .gitignore -Naur intel-driver/src/gen9_mfd.c isg_gms-intel-va-driver/src/gen9_mfd.c
--- intel-driver/src/gen9_mfd.c	2016-08-08 02:32:16.154448256 +0800
+++ isg_gms-intel-va-driver/src/gen9_mfd.c	2016-08-08 02:32:09.006326399 +0800
@@ -1989,3 +1989,17 @@
         return gen8_dec_hw_context_init(ctx, obj_config);
     }
 }
+
+void gen9_max_resolution(struct i965_driver_data *i965,
+                         struct object_config *obj_config,
+                         int *w,                                /* out */
+                         int *h)                                /* out */
+{
+    if (obj_config->profile == VAProfileJPEGBaseline) {
+        *w = 8192;
+        *h = 8192;
+    } else {
+        *w = i965->codec_info->max_width;
+        *h = i965->codec_info->max_height;
+    }
+}
diff -x .git -x .gitignore -Naur intel-driver/src/gen9_vdenc.c isg_gms-intel-va-driver/src/gen9_vdenc.c
--- intel-driver/src/gen9_vdenc.c	2016-08-08 02:32:16.158448324 +0800
+++ isg_gms-intel-va-driver/src/gen9_vdenc.c	2016-08-08 02:32:09.014326535 +0800
@@ -778,7 +778,7 @@
         OUT_BCS_BATCH(batch, attr);                             \
     } while (0)
 
-#define ALLOC_VDENC_BUFFER_RESOURCE(buffer, bfsize, des) {      \
+#define ALLOC_VDENC_BUFFER_RESOURCE(buffer, bfsize, des) do {   \
         buffer.type = I965_GPE_RESOURCE_BUFFER;                 \
         buffer.width = bfsize;                                  \
         buffer.height = 1;                                      \
diff -x .git -x .gitignore -Naur intel-driver/src/i965_defines.h isg_gms-intel-va-driver/src/i965_defines.h
--- intel-driver/src/i965_defines.h	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_defines.h	2016-08-08 02:32:09.022326671 +0800
@@ -978,4 +978,6 @@
 #define MFC_BITSTREAM_BYTECOUNT_FRAME_REG       0x128A0
 #define MFC_IMAGE_STATUS_CTRL_REG               0x128B8
 
+#define GEN9_CACHE_PTE                  0x02
+
 #endif /* _I965_DEFINES_H_ */
diff -x .git -x .gitignore -Naur intel-driver/src/i965_device_info.c isg_gms-intel-va-driver/src/i965_device_info.c
--- intel-driver/src/i965_device_info.c	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_device_info.c	2016-08-08 02:32:09.022326671 +0800
@@ -239,7 +239,7 @@
 
     .max_width = 4096,
     .max_height = 4096,
-    .min_linear_wpitch = 128,
+    .min_linear_wpitch = 64,
     .min_linear_hpitch = 16,
 
     .h264_mvc_dec_profiles = (VA_PROFILE_MASK(H264StereoHigh) |
@@ -282,7 +282,7 @@
 
     .max_width = 4096,
     .max_height = 4096,
-    .min_linear_wpitch = 128,
+    .min_linear_wpitch = 64,
     .min_linear_hpitch = 16,
 
     .h264_mvc_dec_profiles = (VA_PROFILE_MASK(H264StereoHigh) |
@@ -321,16 +321,18 @@
 
 extern struct hw_context *gen9_enc_hw_context_init(VADriverContextP, struct object_config *);
 extern void gen9_post_processing_context_init(VADriverContextP, void *, struct intel_batchbuffer *);
+extern void gen9_max_resolution(struct i965_driver_data *, struct object_config *, int *, int *);
 static struct hw_codec_info skl_hw_codec_info = {
     .dec_hw_context_init = gen9_dec_hw_context_init,
     .enc_hw_context_init = gen9_enc_hw_context_init,
     .proc_hw_context_init = gen75_proc_context_init,
     .render_init = gen9_render_init,
     .post_processing_context_init = gen9_post_processing_context_init,
+    .max_resolution = gen9_max_resolution,
 
-    .max_width = 4096,
-    .max_height = 4096,
-    .min_linear_wpitch = 128,
+    .max_width = 4096,  /* default. See max_resolution */
+    .max_height = 4096, /* default. See max_resolution */
+    .min_linear_wpitch = 64,
     .min_linear_hpitch = 16,
 
     .h264_mvc_dec_profiles = (VA_PROFILE_MASK(H264StereoHigh) |
@@ -378,10 +380,11 @@
     .proc_hw_context_init = gen75_proc_context_init,
     .render_init = gen9_render_init,
     .post_processing_context_init = gen9_post_processing_context_init,
+    .max_resolution = gen9_max_resolution,
 
-    .max_width = 4096,
-    .max_height = 4096,
-    .min_linear_wpitch = 128,
+    .max_width = 4096,  /* default. See max_resolution */
+    .max_height = 4096, /* default. See max_resolution */
+    .min_linear_wpitch = 64,
     .min_linear_hpitch = 16,
 
     .h264_mvc_dec_profiles = (VA_PROFILE_MASK(H264StereoHigh) |
@@ -430,10 +433,11 @@
     .proc_hw_context_init = gen75_proc_context_init,
     .render_init = gen9_render_init,
     .post_processing_context_init = gen9_post_processing_context_init,
+    .max_resolution = gen9_max_resolution,
 
-    .max_width = 4096,
-    .max_height = 4096,
-    .min_linear_wpitch = 128,
+    .max_width = 4096,   /* default. See max_resolution */
+    .max_height = 4096,  /* default. See max_resolution */
+    .min_linear_wpitch = 64,
     .min_linear_hpitch = 16,
 
     .h264_mvc_dec_profiles = (VA_PROFILE_MASK(H264StereoHigh) |
diff -x .git -x .gitignore -Naur intel-driver/src/i965_drv_video.c isg_gms-intel-va-driver/src/i965_drv_video.c
--- intel-driver/src/i965_drv_video.c	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_drv_video.c	2016-08-08 02:32:09.022326671 +0800
@@ -2130,6 +2130,20 @@
     object_heap_free(heap, obj);
 }
 
+static inline void
+max_resolution(struct i965_driver_data *i965,
+               struct object_config *obj_config,
+               int *w,                                  /* out */
+               int *h)                                  /* out */
+{
+    if (i965->codec_info->max_resolution) {
+        i965->codec_info->max_resolution(i965, obj_config, w, h);
+    } else {
+        *w = i965->codec_info->max_width;
+        *h = i965->codec_info->max_height;
+    }
+}
+
 VAStatus
 i965_CreateContext(VADriverContextP ctx,
                    VAConfigID config_id,
@@ -2147,14 +2161,18 @@
     VAStatus vaStatus = VA_STATUS_SUCCESS;
     int contextID;
     int i;
+    int max_width;
+    int max_height;
 
     if (NULL == obj_config) {
         vaStatus = VA_STATUS_ERROR_INVALID_CONFIG;
         return vaStatus;
     }
 
-    if (picture_width > i965->codec_info->max_width ||
-        picture_height > i965->codec_info->max_height) {
+    max_resolution(i965, obj_config, &max_width, &max_height);
+
+    if (picture_width > max_width ||
+        picture_height > max_height) {
         vaStatus = VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED;
         return vaStatus;
     }
@@ -4144,10 +4162,12 @@
 
         case VA_FOURCC_YV16:
             obj_surface->cb_cr_width = obj_surface->orig_width / 2;
+            obj_surface->width = ALIGN(obj_surface->cb_cr_width, i965->codec_info->min_linear_wpitch) * 2;
             obj_surface->cb_cr_height = obj_surface->orig_height;
             obj_surface->y_cr_offset = obj_surface->height;
             obj_surface->y_cb_offset = obj_surface->y_cr_offset + ALIGN(obj_surface->cb_cr_height, 32) / 2;
             obj_surface->cb_cr_pitch = obj_surface->width / 2;
+            region_width = obj_surface->width;
             region_height = obj_surface->height + ALIGN(obj_surface->cb_cr_height, 32);
             break;
 
@@ -4162,8 +4182,10 @@
             }
 
             obj_surface->cb_cr_width = obj_surface->orig_width / 2;
+            obj_surface->width = ALIGN(obj_surface->cb_cr_width, i965->codec_info->min_linear_wpitch) * 2;
             obj_surface->cb_cr_height = obj_surface->orig_height / 2;
             obj_surface->cb_cr_pitch = obj_surface->width / 2;
+            region_width = obj_surface->width;
             region_height = obj_surface->height + obj_surface->height / 2;
             break;
 
@@ -5485,7 +5507,9 @@
     struct object_config *obj_config;
     int i = 0;
     VASurfaceAttrib *attribs = NULL;
-    
+    int max_width;
+    int max_height;
+
     if (config == VA_INVALID_ID)
         return VA_STATUS_ERROR_INVALID_CONFIG;
 
@@ -5873,16 +5897,18 @@
     attribs[i].value.value.p = NULL; /* ignore */
     i++;
 
+    max_resolution(i965, obj_config, &max_width, &max_height);
+
     attribs[i].type = VASurfaceAttribMaxWidth;
     attribs[i].value.type = VAGenericValueTypeInteger;
     attribs[i].flags = VA_SURFACE_ATTRIB_GETTABLE;
-    attribs[i].value.value.i = i965->codec_info->max_width;
+    attribs[i].value.value.i = max_width;
     i++;
 
     attribs[i].type = VASurfaceAttribMaxHeight;
     attribs[i].value.type = VAGenericValueTypeInteger;
     attribs[i].flags = VA_SURFACE_ATTRIB_GETTABLE;
-    attribs[i].value.value.i = i965->codec_info->max_height;
+    attribs[i].value.value.i = max_height;
     i++;
 
     if (i > *num_attribs) {
diff -x .git -x .gitignore -Naur intel-driver/src/i965_drv_video.h isg_gms-intel-va-driver/src/i965_drv_video.h
--- intel-driver/src/i965_drv_video.h	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_drv_video.h	2016-08-08 02:32:09.022326671 +0800
@@ -354,6 +354,8 @@
     int ring;
 };
 
+struct i965_driver_data;
+
 struct hw_codec_info
 {
     struct hw_context *(*dec_hw_context_init)(VADriverContextP, struct object_config *);
@@ -363,6 +365,13 @@
     void (*post_processing_context_init)(VADriverContextP, void *, struct intel_batchbuffer *);
     void (*preinit_hw_codec)(VADriverContextP, struct hw_codec_info *);
 
+    /**
+     * Allows HW info to support per-codec max resolution.  If this functor is
+     * not initialized, then @max_width and @max_height will be used as the
+     * default maximum resolution for all codecs on this HW info.
+     */
+    void (*max_resolution)(struct i965_driver_data *, struct object_config *, int *, int *);
+
     int max_width;
     int max_height;
     int min_linear_wpitch;
diff -x .git -x .gitignore -Naur intel-driver/src/i965_gpe_utils.c isg_gms-intel-va-driver/src/i965_gpe_utils.c
--- intel-driver/src/i965_gpe_utils.c	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_gpe_utils.c	2016-08-08 02:32:09.022326671 +0800
@@ -721,6 +721,7 @@
                             struct object_surface *obj_surface,
                             struct gen8_surface_state2 *ss)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     int w, h, w_pitch;
     unsigned int tiling, swizzle;
 
@@ -734,6 +735,9 @@
 
     memset(ss, 0, sizeof(*ss));
     /* ss0 */
+    if (IS_GEN9(i965->intel.device_info))
+        ss->ss5.surface_object_mocs = GEN9_CACHE_PTE;
+
     ss->ss6.base_addr = (uint32_t)obj_surface->bo->offset64;
     ss->ss7.base_addr_high = (uint32_t)(obj_surface->bo->offset64 >> 32);
     /* ss1 */
@@ -782,6 +786,7 @@
                                     struct object_surface *obj_surface,
                                     struct gen8_surface_state *ss)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     int w, h, w_pitch;
     unsigned int tiling, swizzle;
 
@@ -792,6 +797,9 @@
 
     memset(ss, 0, sizeof(*ss));
     /* ss0 */
+    if (IS_GEN9(i965->intel.device_info))
+        ss->ss1.surface_mocs = GEN9_CACHE_PTE;
+
     ss->ss0.surface_type = I965_SURFACE_2D;
     ss->ss0.surface_format = I965_SURFACEFORMAT_R8_UNORM;
     /* ss1 */
@@ -810,6 +818,7 @@
                                     struct object_surface *obj_surface,
                                     struct gen8_surface_state *ss)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     int w, w_pitch;
     unsigned int tiling, swizzle;
     int cbcr_offset;
@@ -822,6 +831,9 @@
     cbcr_offset = obj_surface->height * obj_surface->width;
     memset(ss, 0, sizeof(*ss));
     /* ss0 */
+    if (IS_GEN9(i965->intel.device_info))
+        ss->ss1.surface_mocs = GEN9_CACHE_PTE;
+
     ss->ss0.surface_type = I965_SURFACE_2D;
     ss->ss0.surface_format = I965_SURFACEFORMAT_R8_UNORM;
     /* ss1 */
@@ -897,6 +909,7 @@
                                   struct i965_buffer_surface *buffer_surface,
                                   struct gen8_surface_state *ss)
 {
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
     int num_entries;
 
     assert(buffer_surface->bo);
@@ -905,6 +918,9 @@
     memset(ss, 0, sizeof(*ss));
     /* ss0 */
     ss->ss0.surface_type = I965_SURFACE_BUFFER;
+    if (IS_GEN9(i965->intel.device_info))
+        ss->ss1.surface_mocs = GEN9_CACHE_PTE;
+
     /* ss1 */
     ss->ss8.base_addr = (uint32_t)buffer_surface->bo->offset64;
     ss->ss9.base_addr_high = (uint32_t)(buffer_surface->bo->offset64 >> 32);
diff -x .git -x .gitignore -Naur intel-driver/src/i965_pciids.h isg_gms-intel-va-driver/src/i965_pciids.h
--- intel-driver/src/i965_pciids.h	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/i965_pciids.h	2016-08-08 02:32:09.026326740 +0800
@@ -174,14 +174,12 @@
 CHIPSET(0x5912, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x5917, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x5902, kbl, kbl,       "Intel(R) Kabylake")
-CHIPSET(0x5932, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x591B, kbl, kbl,       "Intel(R) Kabylake")
-CHIPSET(0x592B, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x593B, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x590B, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x591A, kbl, kbl,       "Intel(R) Kabylake")
-CHIPSET(0x592A, kbl, kbl,       "Intel(R) Kabylake")
-CHIPSET(0x593A, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x590A, kbl, kbl,       "Intel(R) Kabylake")
 CHIPSET(0x591D, kbl, kbl,       "Intel(R) Kabylake")
-CHIPSET(0x593D, kbl, kbl,       "Intel(R) Kabylake")
\ No newline at end of file
+CHIPSET(0x5908, kbl, kbl,       "Intel(R) Kabylake")
+CHIPSET(0x5923, kbl, kbl,       "Intel(R) Kabylake")
+CHIPSET(0x5927, kbl, kbl,       "Intel(R) Kabylake")
diff -x .git -x .gitignore -Naur intel-driver/src/shaders/utils/Makefile.am isg_gms-intel-va-driver/src/shaders/utils/Makefile.am
--- intel-driver/src/shaders/utils/Makefile.am	2016-08-08 02:32:16.162448393 +0800
+++ isg_gms-intel-va-driver/src/shaders/utils/Makefile.am	2016-08-08 02:32:09.118328308 +0800
@@ -24,9 +24,14 @@
 INTEL_GEN75_INC	= mfc_batchbuffer_hsw.inc
 INTEL_GEN75_ASM	= $(INTEL_G75A:%.g75a=%.gen75.asm)
 
-INTEL_G9B	= mfc_batchbuffer_avc_intra.g9b mfc_batchbuffer_avc_inter.g9b
-INTEL_G9A	= mfc_batchbuffer_avc_intra.g9a mfc_batchbuffer_avc_inter.g9a
-INTEL_GEN9_INC	= mfc_batchbuffer.inc
+INTEL_G8B	= mfc_batchbuffer_hsw.g8b
+INTEL_G8A	= mfc_batchbuffer_hsw.g8a
+INTEL_GEN8_INC	= mfc_batchbuffer_hsw.inc
+INTEL_GEN8_ASM	= $(INTEL_G9A:%.g9a=%.gen8.asm)
+
+INTEL_G9B	= mfc_batchbuffer_hsw.g9b
+INTEL_G9A	= mfc_batchbuffer_hsw.g9a
+INTEL_GEN9_INC	= mfc_batchbuffer_hsw.inc
 INTEL_GEN9_ASM	= $(INTEL_G9A:%.g9a=%.gen9.asm)
 
 TARGETS  =
@@ -34,12 +39,13 @@
 TARGETS += $(INTEL_G6B)
 TARGETS += $(INTEL_G7B)
 TARGETS += $(INTEL_G75B)
+TARGETS += $(INTEL_G8B)
 TARGETS += $(INTEL_G9B)
 endif
 
 all-local: $(TARGETS)
 
-SUFFIXES = .g6a .g6b .g7a .g7b .gen6.asm .gen7.asm .g75a .g75b .gen75.asm .g9a .g9b .gen9.asm
+SUFFIXES = .g6a .g6b .g7a .g7b .gen6.asm .gen7.asm .g75a .g75b .gen75.asm .g9a .g9b .gen9.asm .g8a .g8b .gen8.asm
 
 if HAVE_GEN4ASM
 $(INTEL_GEN6_ASM): $(MFC_CORE) $(MFC_CORE_AVC) $(INTEL_GEN6_INC)
@@ -66,9 +72,17 @@
 .gen75.asm.g75b:
 	$(AM_V_GEN)$(GEN4ASM) -g 7.5 -o $@ $<
 
-$(INTEL_GEN9_ASM): $(MFC_CORE) $(MFC_CORE_AVC) $(INTEL_GEN9_INC)
+$(INTEL_GEN8_ASM): $(MFC_CORE_HSW) $(INTEL_GEN8_INC)
+.g8a.gen8.asm:
+	$(AM_V_GEN)cpp -P $< > _mfc0.$@			&& \
+	m4 _mfc0.$@ > $@				&& \
+	rm _mfc0.$@
+.gen8.asm.g8b:
+	$(AM_V_GEN)$(GEN4ASM) -g 8 -o $@ $<
+
+$(INTEL_GEN9_ASM): $(MFC_CORE_HSW) $(INTEL_GEN8_INC)
 .g9a.gen9.asm:
-	$(AM_V_GEN)cpp -P -DDEV_IVB $< > _mfc0.$@ 	&& \
+	$(AM_V_GEN)cpp -P $< > _mfc0.$@			&& \
 	m4 _mfc0.$@ > $@				&& \
 	rm _mfc0.$@
 .gen9.asm.g9b:
@@ -76,7 +90,7 @@
 
 endif
 
-CLEANFILES = $(INTEL_GEN6_ASM) $(INTEL_GEN7_ASM) $(INTEL_GEN75_ASM) $(INTEL_GEN9_ASM)
+CLEANFILES = $(INTEL_GEN6_ASM) $(INTEL_GEN7_ASM) $(INTEL_GEN75_ASM) $(INTEL_GEN9_ASM) $(INTEL_GEN8_ASM)
 
 EXTRA_DIST = \
 	$(INTEL_G6A)		\
@@ -88,6 +102,8 @@
 	$(INTEL_GEN6_INC)	\
 	$(INTEL_GEN7_INC)	\
 	$(INTEL_GEN75_INC)	\
+	$(INTEL_G8A)		\
+	$(INTEL_G8B)		\
 	$(INTEL_G9A)		\
 	$(INTEL_G9B)		\
 	$(INTEL_GEN9_INC)	\
diff -x .git -x .gitignore -Naur intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8a isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8a
--- intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8a	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8a	2016-08-08 02:32:09.118328308 +0800
@@ -0,0 +1,28 @@
+/*
+ * Copyright  2010-2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhao Yakui <yakui.zhao@intel.com>
+ */
+
+#include "mfc_batchbuffer_hsw.inc"
+#include "mfc_batchbuffer_hsw.asm"
diff -x .git -x .gitignore -Naur intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8b isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8b
--- intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8b	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g8b	2016-08-08 02:32:09.118328308 +0800
@@ -0,0 +1,105 @@
+   { 0x00800001, 0x23400608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x21e00608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x2b000608, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x2ac00608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x2ac02248, 0x000000a8, 0x00000000 },
+   { 0x00000001, 0x2ac22248, 0x000000a9, 0x00000000 },
+   { 0x00000001, 0x2ae02248, 0x000000b0, 0x00000000 },
+   { 0x00000001, 0x2ae22248, 0x000000b1, 0x00000000 },
+   { 0x00000001, 0x2ae41248, 0x000000ac, 0x00000000 },
+   { 0x00000001, 0x2ae80608, 0x00000000, 0x00000002 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010001, 0x2ae80608, 0x00000000, 0x00000018 },
+   { 0x00000001, 0x21e80208, 0x000000a0, 0x00000000 },
+   { 0x00000001, 0x21f42288, 0x00000014, 0x00000000 },
+   { 0x00000041, 0x2b081208, 0x120000aa, 0x00000ac2 },
+   { 0x00000040, 0x2b080208, 0x12000b08, 0x00000ac0 },
+   { 0x00000041, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000001, 0x2b142288, 0x00000014, 0x00000000 },
+   { 0x00000001, 0x23400608, 0x00000000, 0x7149000a },
+   { 0x00000001, 0x23540608, 0x00000000, 0x000f000f },
+   { 0x00000001, 0x23680608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23582288, 0x000000a6, 0x00000000 },
+   { 0x00600001, 0x2b400208, 0x008d0b00, 0x00000000 },
+   { 0x00000001, 0x23500608, 0x00000000, 0xffff0000 },
+   { 0x00000001, 0x21002288, 0x00000ac0, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000ac2, 0x00000000 },
+   { 0x00000001, 0x23501248, 0x00000100, 0x00000000 },
+   { 0x00000001, 0x235a1648, 0x10000000, 0x00000000 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x00000ae0 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x12000ac2, 0x00000ae2 },
+   { 0x00010001, 0x235a1648, 0x10000000, 0x04000400 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000040 },
+   { 0x0a800031, 0x2b600a08, 0x0e000b40, 0x02180200 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x00000240 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x0e000b40, 0x02280300 },
+   { 0x05000010, 0x20001260, 0x12000b70, 0x00000b88 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000001f0 },
+   { 0x00000005, 0x234c0208, 0x06000b80, 0x1f00ffff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e0000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x00000001, 0x23440608, 0x00000000, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00030003 },
+   { 0x00110040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000050 },
+   { 0x02000005, 0x20001200, 0x16000b84, 0xff00ff00 },
+   { 0x00010001, 0x23440608, 0x00000000, 0x00000080 },
+   { 0x00010040, 0x234c0208, 0x0600034c, 0x00600000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000000c0 },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00000000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000080 },
+   { 0x00000040, 0x2b480208, 0x06000b48, 0x00000003 },
+   { 0x0a800031, 0x2ba00a08, 0x0e000b40, 0x02480400 },
+   { 0x00200001, 0x2ba80208, 0x00450bc0, 0x00000000 },
+   { 0x00200001, 0x2bb00208, 0x00450be0, 0x00000000 },
+   { 0x00200001, 0x2bb80208, 0x00450c00, 0x00000000 },
+   { 0x00600001, 0x28000208, 0x008d0b40, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0ba0, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0200 },
+   { 0x00000001, 0x23600208, 0x000000b4, 0x00000000 },
+   { 0x00000001, 0x23640208, 0x000000b8, 0x00000000 },
+   { 0x00000001, 0x235c0608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c2288, 0x00000b85, 0x00000000 },
+   { 0x00000001, 0x235d2288, 0x00000b86, 0x00000000 },
+   { 0x00000040, 0x21040208, 0x06000b08, 0x00000003 },
+   { 0x00000041, 0x23480208, 0x06000104, 0x00000010 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x000000b0 },
+   { 0x00200001, 0x23440608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c0208, 0x00000b64, 0x00000000 },
+   { 0x00000001, 0x23600208, 0x00000b68, 0x00000000 },
+   { 0x00000001, 0x23640608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23642288, 0x00000b6c, 0x00000000 },
+   { 0x00000005, 0x234c0208, 0x06000b60, 0x0000c0ff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e2000 },
+   { 0x00000001, 0x21000608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000b62, 0x00000000 },
+   { 0x00000005, 0x21001248, 0x16000100, 0x1f001f00 },
+   { 0x00000040, 0x234c0208, 0x0200034c, 0x00000100 },
+   { 0x00600001, 0x28000208, 0x008d01e0, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0340, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0202 },
+   { 0x00000040, 0x28080208, 0x06000808, 0x00000002 },
+   { 0x00600001, 0x28200208, 0x008d0360, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x0e000800, 0x040a0002 },
+   { 0x00000040, 0x2ac41248, 0x16000ac4, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac4, 0x00000ae4 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000090 },
+   { 0x00000040, 0x21e80208, 0x160001e8, 0x00030003 },
+   { 0x00000040, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000040, 0x2ac01248, 0x16000ac0, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x000000aa },
+   { 0x00010040, 0x2ac21248, 0x16000ac2, 0x00010001 },
+   { 0x00010001, 0x2ac01648, 0x10000000, 0x00000000 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0xfffffb30 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x0e000800, 0x0219e002 },
+   { 0x00600001, 0x2e000208, 0x008d0000, 0x00000000 },
+   { 0x07000031, 0x24000a40, 0x0e000e00, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
diff -x .git -x .gitignore -Naur intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9a isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9a
--- intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9a	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9a	2016-08-08 02:32:09.118328308 +0800
@@ -0,0 +1,28 @@
+/*
+ * Copyright  2010-2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhao Yakui <yakui.zhao@intel.com>
+ */
+
+#include "mfc_batchbuffer_hsw.inc"
+#include "mfc_batchbuffer_hsw.asm"
diff -x .git -x .gitignore -Naur intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9b isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9b
--- intel-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9b	1970-01-01 07:30:00.000000000 +0730
+++ isg_gms-intel-va-driver/src/shaders/utils/mfc_batchbuffer_hsw.g9b	2016-08-08 02:32:09.118328308 +0800
@@ -0,0 +1,105 @@
+   { 0x00800001, 0x23400608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x21e00608, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x2b000608, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x2ac00608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x2ac02248, 0x000000a8, 0x00000000 },
+   { 0x00000001, 0x2ac22248, 0x000000a9, 0x00000000 },
+   { 0x00000001, 0x2ae02248, 0x000000b0, 0x00000000 },
+   { 0x00000001, 0x2ae22248, 0x000000b1, 0x00000000 },
+   { 0x00000001, 0x2ae41248, 0x000000ac, 0x00000000 },
+   { 0x00000001, 0x2ae80608, 0x00000000, 0x00000002 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010001, 0x2ae80608, 0x00000000, 0x00000018 },
+   { 0x00000001, 0x21e80208, 0x000000a0, 0x00000000 },
+   { 0x00000001, 0x21f42288, 0x00000014, 0x00000000 },
+   { 0x00000041, 0x2b081208, 0x120000aa, 0x00000ac2 },
+   { 0x00000040, 0x2b080208, 0x12000b08, 0x00000ac0 },
+   { 0x00000041, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000001, 0x2b142288, 0x00000014, 0x00000000 },
+   { 0x00000001, 0x23400608, 0x00000000, 0x7149000a },
+   { 0x00000001, 0x23540608, 0x00000000, 0x000f000f },
+   { 0x00000001, 0x23680608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23582288, 0x000000a6, 0x00000000 },
+   { 0x00600001, 0x2b400208, 0x008d0b00, 0x00000000 },
+   { 0x00000001, 0x23500608, 0x00000000, 0xffff0000 },
+   { 0x00000001, 0x21002288, 0x00000ac0, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000ac2, 0x00000000 },
+   { 0x00000001, 0x23501248, 0x00000100, 0x00000000 },
+   { 0x00000001, 0x235a1648, 0x10000000, 0x00000000 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x00000ae0 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x12000ac2, 0x00000ae2 },
+   { 0x00010001, 0x235a1648, 0x10000000, 0x04000400 },
+   { 0x01000005, 0x20002240, 0x160000a4, 0x00010001 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000040 },
+   { 0x0a800031, 0x2b600a08, 0x06000b40, 0x02180200 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x00000240 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x06000b40, 0x02280300 },
+   { 0x05000010, 0x20001260, 0x12000b70, 0x00000b88 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000001f0 },
+   { 0x00000005, 0x234c0208, 0x06000b80, 0x1f00ffff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e0000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x00000001, 0x23440608, 0x00000000, 0x00000020 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00030003 },
+   { 0x00110040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00110020, 0x34000000, 0x0e001400, 0x00000050 },
+   { 0x02000005, 0x20001200, 0x16000b84, 0xff00ff00 },
+   { 0x00010001, 0x23440608, 0x00000000, 0x00000080 },
+   { 0x00010040, 0x234c0208, 0x0600034c, 0x00600000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x000000c0 },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x00400000 },
+   { 0x00000005, 0x21001248, 0x16000b80, 0x00030003 },
+   { 0x01000010, 0x20001240, 0x16000100, 0x00000000 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000080 },
+   { 0x00000040, 0x2b480208, 0x06000b48, 0x00000003 },
+   { 0x0a800031, 0x2ba00a08, 0x06000b40, 0x02480400 },
+   { 0x00200001, 0x2ba80208, 0x00450bc0, 0x00000000 },
+   { 0x00200001, 0x2bb00208, 0x00450be0, 0x00000000 },
+   { 0x00200001, 0x2bb80208, 0x00450c00, 0x00000000 },
+   { 0x00600001, 0x28000208, 0x008d0b40, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0ba0, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0200 },
+   { 0x00000001, 0x23600208, 0x000000b4, 0x00000000 },
+   { 0x00000001, 0x23640208, 0x000000b8, 0x00000000 },
+   { 0x00000001, 0x235c0608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c2288, 0x00000b85, 0x00000000 },
+   { 0x00000001, 0x235d2288, 0x00000b86, 0x00000000 },
+   { 0x00000040, 0x21040208, 0x06000b08, 0x00000003 },
+   { 0x00000041, 0x23480208, 0x06000104, 0x00000010 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0x000000b0 },
+   { 0x00200001, 0x23440608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x235c0208, 0x00000b64, 0x00000000 },
+   { 0x00000001, 0x23600208, 0x00000b68, 0x00000000 },
+   { 0x00000001, 0x23640608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x23642288, 0x00000b6c, 0x00000000 },
+   { 0x00000005, 0x234c0208, 0x06000b60, 0x0000c0ff },
+   { 0x00000040, 0x234c0208, 0x0600034c, 0x000e2000 },
+   { 0x00000001, 0x21000608, 0x00000000, 0x00000000 },
+   { 0x00000001, 0x21012288, 0x00000b62, 0x00000000 },
+   { 0x00000005, 0x21001248, 0x16000100, 0x1f001f00 },
+   { 0x00000040, 0x234c0208, 0x0200034c, 0x00000100 },
+   { 0x00600001, 0x28000208, 0x008d01e0, 0x00000000 },
+   { 0x00600001, 0x28200208, 0x008d0340, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0202 },
+   { 0x00000040, 0x28080208, 0x06000808, 0x00000002 },
+   { 0x00600001, 0x28200208, 0x008d0360, 0x00000000 },
+   { 0x0a800031, 0x20000a60, 0x06000800, 0x040a0002 },
+   { 0x00000040, 0x2ac41248, 0x16000ac4, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac4, 0x00000ae4 },
+   { 0x00010020, 0x34000000, 0x0e001400, 0x00000090 },
+   { 0x00000040, 0x21e80208, 0x160001e8, 0x00030003 },
+   { 0x00000040, 0x2b080208, 0x02000b08, 0x00000ae8 },
+   { 0x00000040, 0x2ac01248, 0x16000ac0, 0x00010001 },
+   { 0x01000010, 0x20001240, 0x12000ac0, 0x000000aa },
+   { 0x00010040, 0x2ac21248, 0x16000ac2, 0x00010001 },
+   { 0x00010001, 0x2ac01648, 0x10000000, 0x00000000 },
+   { 0x00000020, 0x34000000, 0x0e001400, 0xfffffb30 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x0a800031, 0x2b600a08, 0x06000800, 0x0219e002 },
+   { 0x00600001, 0x2e000208, 0x008d0000, 0x00000000 },
+   { 0x07000031, 0x24000a40, 0x06000e00, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
