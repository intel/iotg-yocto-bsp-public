From 52e0104ad4ce8bcd0db76df1bd3882cf6abf48ed Mon Sep 17 00:00:00 2001
From: "Bandi,Kushal" <kushal.bandi@intel.com>
Date: Fri, 25 May 2018 03:38:04 +0800
Subject: [PATCH 115/129] media: intel-ipu4: [VIRT] Base code for IPU virtio
 support.

Change-Id: Iada14ecdc1d7a4f5601704cd2b9f1dc0b4cb27de
Signed-off-by: Yu, Ong Hock <ong.hock.yu@intel.com>
Signed-off-by: Bandi, Kushal <kushal.bandi@intel.com>
---
 drivers/media/pci/intel/Kconfig                    |  20 +
 drivers/media/pci/intel/Makefile                   |   1 +
 .../media/pci/intel/ici/ici-isys-stream-device.h   |   4 +
 drivers/media/pci/intel/virtio/Makefile            |  10 +
 drivers/media/pci/intel/virtio/Makefile.virt       |  18 +
 .../pci/intel/virtio/intel-ipu4-para-virt-drv.c    | 352 ++++++++++++++++
 .../pci/intel/virtio/intel-ipu4-para-virt-drv.h    |  21 +
 .../media/pci/intel/virtio/intel-ipu4-virtio-be.c  | 446 +++++++++++++++++++++
 .../pci/intel/virtio/intel-ipu4-virtio-bridge.c    | 201 ++++++++++
 .../pci/intel/virtio/intel-ipu4-virtio-bridge.h    |  25 ++
 .../pci/intel/virtio/intel-ipu4-virtio-common.c    |  76 ++++
 .../pci/intel/virtio/intel-ipu4-virtio-common.h    | 119 ++++++
 .../media/pci/intel/virtio/intel-ipu4-virtio-fe.c  | 237 +++++++++++
 13 files changed, 1530 insertions(+)
 create mode 100644 drivers/media/pci/intel/virtio/Makefile
 create mode 100644 drivers/media/pci/intel/virtio/Makefile.virt
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c

diff --git a/drivers/media/pci/intel/Kconfig b/drivers/media/pci/intel/Kconfig
index c930a93..e328121 100644
--- a/drivers/media/pci/intel/Kconfig
+++ b/drivers/media/pci/intel/Kconfig
@@ -68,3 +68,23 @@ config VIDEO_INTEL_UOS
 	---help---
 	If selected UOS driver components will be compiled
 
+config VIDEO_INTEL_IPU_ACRN
+	bool "Compile for virtio mediation"
+
+choice
+    prompt "Virtio driver type"
+    depends on VIDEO_INTEL_IPU_ACRN
+    default VIDEO_INTEL_IPU_VIRTIO_BE
+
+config VIDEO_INTEL_IPU_VIRTIO_BE
+    bool "Configure IPU4 as virtio backend"
+    depends on VBS
+	---help---
+    Configuring IPU4 driver as virtio backend
+
+config VIDEO_INTEL_IPU_VIRTIO_FE
+    bool "Configure IPU4 as virtio frontend"
+    ---help---
+    Configuring IPU4 driver as virtio frontend
+
+endchoice
diff --git a/drivers/media/pci/intel/Makefile b/drivers/media/pci/intel/Makefile
index 63dd58b..0aeba66 100644
--- a/drivers/media/pci/intel/Makefile
+++ b/drivers/media/pci/intel/Makefile
@@ -10,6 +10,7 @@ subdir-ccflags-y += $(call cc-disable-warning, missing-field-initializers)
 subdir-ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
 
 obj-$(CONFIG_VIDEO_INTEL_ICI)	+= ici/
+obj-$(CONFIG_VIDEO_INTEL_IPU_ACRN)	+= virtio/
 ifndef CONFIG_VIDEO_INTEL_ICI
 obj-$(CONFIG_VIDEO_INTEL_IPU4)	+= ipu4/
 endif
diff --git a/drivers/media/pci/intel/ici/ici-isys-stream-device.h b/drivers/media/pci/intel/ici/ici-isys-stream-device.h
index 89780ce..2b44fa4 100644
--- a/drivers/media/pci/intel/ici/ici-isys-stream-device.h
+++ b/drivers/media/pci/intel/ici/ici-isys-stream-device.h
@@ -14,6 +14,7 @@
 
 #include "ici-isys-frame-buf.h"
 #include "ici-isys-pipeline.h"
+#include "virtio/intel-ipu4-virtio-common.h"
 
 struct ici_ioctl_ops;
 struct ici_frame_plane;
@@ -29,6 +30,9 @@ struct ici_stream_device {
 	int minor;			/* driver minor */
 	unsigned long flags;		/* stream device state machine */
 	const struct ici_ioctl_ops *ipu_ioctl_ops;
+	//Mediator param
+	int virt_dev_id;
+	struct ipu4_virtio_priv *virt_priv;
 };
 
 struct ici_ioctl_ops {
diff --git a/drivers/media/pci/intel/virtio/Makefile b/drivers/media/pci/intel/virtio/Makefile
new file mode 100644
index 0000000..0f4eab5
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/Makefile
@@ -0,0 +1,10 @@
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+IPU_STEP = bxtB0
+
+include $(srcpath)/$(src)/Makefile.virt
+
+ccflags-y += -I$(srcpath)/$(src)/../../../../../include/
+ccflags-y += -I$(srcpath)/$(src)/../
diff --git a/drivers/media/pci/intel/virtio/Makefile.virt b/drivers/media/pci/intel/virtio/Makefile.virt
new file mode 100644
index 0000000..07ece61
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/Makefile.virt
@@ -0,0 +1,18 @@
+ifndef IPU_STEP
+  $(error No IPU_STEP was defined. Stopping.)
+endif
+
+TARGET_MODULE:=intel-ipu-virt-$(IPU_STEP)
+
+$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-common.o
+$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-bridge.o
+
+
+ifdef CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-be.o
+else
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-fe.o
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-para-virt-drv.o
+endif
+
+obj-$(CONFIG_VIDEO_INTEL_IPU_ACRN) := $(TARGET_MODULE).o
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
new file mode 100644
index 0000000..d29be28
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
@@ -0,0 +1,352 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+
+#include "./ici/ici-isys-stream.h"
+#include "intel-ipu4-virtio-common.h"
+#include "intel-ipu4-virtio-bridge.h"
+
+#define MAX_STREAM_DEVICES 64
+
+static dev_t virt_stream_dev_t;
+static struct class *virt_stream_class;
+static int virt_stream_devs_registered;
+static int stream_dev_init;
+static struct ici_stream_device *strm_dev;
+
+
+
+static int ici_isys_set_format(struct file *file, void *fh,
+	struct ici_stream_format *sf)
+{
+	struct ici_stream_device *dev = fh;
+	struct ipu4_virtio_priv *fe_priv = dev->virt_priv;
+	struct ipu4_virtio_req *req;
+	int rval = 0;
+	int op[10];
+
+	if (!fe_priv)
+		return -EINVAL;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	op[0] = 0;
+	op[1] = 0;
+	op[2] = sf->ffmt.width;
+	op[3] =	sf->ffmt.height;
+	op[4] = sf->ffmt.pixelformat;
+	op[5] = sf->ffmt.field;
+	op[6] = sf->ffmt.colorspace;
+	op[7] = 0;
+	op[8] = 0;
+	op[9] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_SET_FORMAT, &op[0]);
+
+	rval = fe_priv->bknd_ops->send_req(fe_priv->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
+
+	return rval;
+}
+
+static int ici_isys_stream_on(struct file *file, void *fh)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static int ici_isys_stream_off(struct file *file, void *fh)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static int ici_isys_getbuf(struct file *file, void *fh,
+	struct ici_frame_info *user_frame_info)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static int ici_isys_putbuf(struct file *file, void *fh,
+	struct ici_frame_info *user_frame_info)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static unsigned int stream_fop_poll(struct file *file,
+	struct poll_table_struct *poll)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static int virt_stream_fop_open(struct inode *inode, struct file *file)
+{
+	struct ici_stream_device *dev = inode_to_intel_ipu_stream_device(inode);
+	struct ipu4_virtio_req *req;
+	struct ipu4_virtio_priv *fe_priv = dev->virt_priv;
+	int rval = 0;
+	int op[2];
+	printk(KERN_INFO "virt stream open\n");
+	get_device(&dev->dev);
+
+	file->private_data = dev;
+
+	if (!fe_priv)
+		return -EINVAL;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	op[0] = dev->virt_dev_id;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_DEVICE_OPEN, &op[0]);
+
+	rval = fe_priv->bknd_ops->send_req(fe_priv->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
+
+	return rval;
+}
+
+static int virt_stream_fop_release(struct inode *inode, struct file *file)
+{
+	int rval = 0;
+
+	return rval;
+}
+
+static unsigned int virt_stream_fop_poll(struct file *file,
+	struct poll_table_struct *poll)
+{
+	struct ici_stream_device *as = file->private_data;
+	unsigned int res = POLLERR | POLLHUP;
+
+	printk(KERN_NOTICE "virt_stream_fop_poll for:%s\n", as->name);
+
+	res = stream_fop_poll(file, poll);
+
+	res = POLLIN;
+
+	printk(KERN_NOTICE "virt_stream_fop_poll res %u\n", res);
+
+	return res;
+}
+
+static long virt_stream_ioctl(struct file *file,
+				unsigned int ioctl_cmd,
+				unsigned long ioctl_arg)
+{
+	union {
+			struct ici_frame_info frame_info;
+			struct ici_stream_format sf;
+		} isys_ioctl_cmd_args;
+		int err = 0;
+		struct ici_stream_device *dev = file->private_data;
+		void __user *up = (void __user *)ioctl_arg;
+
+		bool copy = (ioctl_cmd != ICI_IOC_STREAM_ON &&
+				ioctl_cmd != ICI_IOC_STREAM_OFF);
+
+		if (copy) {
+			if (_IOC_SIZE(ioctl_cmd) > sizeof(isys_ioctl_cmd_args))
+				return -ENOTTY;
+
+			if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
+				err = copy_from_user(&isys_ioctl_cmd_args, up,
+					_IOC_SIZE(ioctl_cmd));
+				if (err)
+					return -EFAULT;
+			}
+		}
+
+		//mutex_lock(dev->mutex);
+		switch (ioctl_cmd) {
+		case ICI_IOC_STREAM_ON:
+			printk(KERN_INFO "IPU FE IOCTL STREAM_ON\n");
+			err = ici_isys_stream_on(file, dev);
+			break;
+		case ICI_IOC_STREAM_OFF:
+			printk(KERN_INFO "IPU FE IOCTL STREAM_OFF\n");
+			err = ici_isys_stream_off(file, dev);
+			break;
+		case ICI_IOC_GET_BUF:
+			printk(KERN_INFO "IPU FE IOCTL GET_BUF\n");
+			err = ici_isys_getbuf(file, dev, &isys_ioctl_cmd_args.frame_info);
+			break;
+		case ICI_IOC_PUT_BUF:
+			printk(KERN_INFO "IPU FE IOCTL PUT_BUF\n");
+			err = ici_isys_putbuf(file, dev, &isys_ioctl_cmd_args.frame_info);
+			break;
+		case ICI_IOC_SET_FORMAT:
+			printk(KERN_INFO "IPU FE IOCTL SET_FORMAT\n");
+			err = ici_isys_set_format(file, dev, &isys_ioctl_cmd_args.sf);
+			break;
+
+		default:
+			err = -ENOTTY;
+			break;
+		}
+
+		//mutex_unlock(dev->mutex);
+	return 0;
+}
+
+
+static const struct file_operations virt_stream_fops = {
+	.owner = THIS_MODULE,
+	.open = virt_stream_fop_open,			/* calls strm_dev->fops->open() */
+	.unlocked_ioctl = virt_stream_ioctl,	/* calls strm_dev->ipu_ioctl_ops->() */
+	.release = virt_stream_fop_release,		/* calls strm_dev->fops->release() */
+	.poll = virt_stream_fop_poll,		/* calls strm_dev->fops->poll() */
+};
+
+/* Called on device_unregister */
+static void base_device_release(struct device *sd)
+{
+}
+
+static int virt_ici_stream_init(void)
+{
+	int rval;
+	int num;
+	struct ipu4_virtio_priv *fe_priv;
+	printk(KERN_NOTICE "Initializing Para virt IPU FE\n");
+	if (!stream_dev_init) {
+		virt_stream_dev_t = MKDEV(MAJOR_STREAM, 0);
+
+		rval = register_chrdev_region(virt_stream_dev_t,
+		MAX_STREAM_DEVICES, ICI_STREAM_DEVICE_NAME);
+		if (rval) {
+			printk(
+					KERN_WARNING "can't register virt_ici stream chrdev region (%d)\n",
+					rval);
+			return rval;
+		}
+
+		virt_stream_class = class_create(THIS_MODULE, ICI_STREAM_DEVICE_NAME);
+		if (IS_ERR(virt_stream_class)) {
+			unregister_chrdev_region(virt_stream_dev_t, MAX_STREAM_DEVICES);
+			printk(KERN_WARNING "Failed to register device class %s\n",
+					ICI_STREAM_DEVICE_NAME);
+			return PTR_ERR(virt_stream_class);
+		}
+		stream_dev_init++;
+	}
+	strm_dev = kzalloc(sizeof(*strm_dev), GFP_KERNEL);
+	if (!strm_dev)
+		return -ENOMEM;
+	num = virt_stream_devs_registered;
+	strm_dev->minor = -1;
+	cdev_init(&strm_dev->cdev, &virt_stream_fops);
+	strm_dev->cdev.owner = virt_stream_fops.owner;
+
+	rval = cdev_add(&strm_dev->cdev, MKDEV(MAJOR(virt_stream_dev_t), num), 1);
+	if (rval) {
+			printk(KERN_WARNING "%s: failed to add cdevice\n", __func__);
+			return rval;
+	}
+
+	strm_dev->dev.class = virt_stream_class;
+	strm_dev->dev.devt = MKDEV(MAJOR(virt_stream_dev_t), num);
+	dev_set_name(&strm_dev->dev, "%s%d", ICI_STREAM_DEVICE_NAME, num);
+
+	rval = device_register(&strm_dev->dev);
+	if (rval < 0) {
+		printk(KERN_WARNING "%s: device_register failed\n", __func__);
+		cdev_del(&strm_dev->cdev);
+		return rval;
+	}
+	strm_dev->dev.release = base_device_release;
+	strlcpy(strm_dev->name, strm_dev->dev.kobj.name, sizeof(strm_dev->name));
+	strm_dev->minor = num;
+	strm_dev->virt_dev_id = num;
+
+	//mutex_init(strm_dev->mutex);
+	//virt_stream_devs_registered++;
+
+	fe_priv = kcalloc(1, sizeof(struct ipu4_virtio_priv),
+					      GFP_KERNEL);
+
+	if (!fe_priv)
+		return -ENOMEM;
+
+	fe_priv->bknd_ops = &ipu4_virtio_bknd_ops;
+
+	if (fe_priv->bknd_ops->init) {
+		rval = fe_priv->bknd_ops->init();
+		if (rval < 0) {
+			printk(KERN_NOTICE
+				"failed to initialize backend.\n");
+			return rval;
+		}
+	}
+
+	fe_priv->domid = fe_priv->bknd_ops->get_vm_id();
+	strm_dev->virt_priv = fe_priv;
+	printk("FE registered with domid:%d\n", fe_priv->domid);
+
+	return 0;
+}
+
+static void virt_ici_stream_exit(void)
+{
+	class_unregister(virt_stream_class);
+	unregister_chrdev_region(virt_stream_dev_t, MAX_STREAM_DEVICES);
+
+	printk(KERN_INFO "virt_ici stream device unregistered\n");
+}
+
+static int __init virt_ici_init(void)
+{
+	return virt_ici_stream_init();
+}
+
+static void __exit virt_ici_exit(void)
+{
+	virt_ici_stream_exit();
+}
+
+module_init(virt_ici_init);
+module_exit(virt_ici_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Intel IPU Para virtualize ici input system driver");
+MODULE_AUTHOR("Kushal Bandi <kushal.bandi@intel.com>");
+
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.h b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.h
new file mode 100644
index 0000000..b36e6f7
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef INTEL_IPU4_PARA_VIRT_H
+#define INTEL_IPU4_PARA_VIRT_H
+
+#include "./ici/ici-isys-stream-device.h"
+#include "./ici/ici-isys-frame-buf.h"
+#include "intel-ipu4-virtio-common.h"
+
+struct virtual_stream {
+	struct mutex mutex;
+	struct ici_stream_device strm_dev;
+	int virt_dev_id;
+	struct ipu4_virtio_priv *priv;
+	struct ici_isys_frame_buf_list buf_list;
+};
+
+#endif INTEL_IPU4_PARA_VIRT_H
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
new file mode 100644
index 0000000..b8e2836
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
@@ -0,0 +1,446 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/uio.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <linux/vbs/vq.h>
+#include <linux/vbs/vbs.h>
+#include <linux/hashtable.h>
+
+#include "intel-ipu4-virtio-common.h"
+#include "intel-ipu4-virtio-bridge.h"
+
+enum {
+	IPU_VIRTIO_RX_QUEUE = 0,
+	IPU_VIRTIO_QUEUE_MAX
+};
+
+/**
+ * struct ipu4_virtio_be_priv - Backend of virtio-rng based on VBS-K
+ *
+ * @dev		: instance of struct virtio_dev_info
+ * @vqs		: instances of struct virtio_vq_info
+ * @hwrng	: device specific member
+ * @node	: hashtable maintaining multiple connections
+ *		  from multiple guests/devices
+ */
+struct ipu4_virtio_be_priv {
+	struct virtio_dev_info dev;
+	struct virtio_vq_info vqs[IPU_VIRTIO_QUEUE_MAX];
+	bool busy;
+	struct ipu4_virtio_req *pending_tx_req;
+	struct mutex lock;
+	/*
+	 * Each VBS-K module might serve multiple connections
+	 * from multiple guests/device models/VBS-Us, so better
+	 * to maintain the connections in a list, and here we
+	 * use hashtable as an example.
+	 */
+	struct hlist_node node;
+};
+
+#define RNG_MAX_HASH_BITS 4		/* MAX is 2^4 */
+#define HASH_NAME vbs_hash
+
+DECLARE_HASHTABLE(HASH_NAME, RNG_MAX_HASH_BITS);
+static int ipu_vbk_hash_initialized;
+static int ipu_vbk_connection_cnt;
+
+/* function declarations */
+static int handle_kick(int client_id, int req_cnt);
+static void ipu_vbk_reset(struct ipu4_virtio_be_priv *rng);
+static void ipu_vbk_stop(struct ipu4_virtio_be_priv *rng);
+static void ipu_vbk_flush(struct ipu4_virtio_be_priv *rng);
+
+#ifdef RUNTIME_CTRL
+static int ipu_vbk_enable_vq(struct ipu4_virtio_be_priv *rng,
+			     struct virtio_vq_info *vq);
+static void ipu_vbk_disable_vq(struct ipu4_virtio_be_priv *rng,
+			       struct virtio_vq_info *vq);
+static void ipu_vbk_stop_vq(struct ipu4_virtio_be_priv *rng,
+			      struct virtio_vq_info *vq);
+static void ipu_vbk_flush_vq(struct ipu4_virtio_be_priv *rng, int index);
+#endif
+
+/* hash table related functions */
+static void ipu_vbk_hash_init(void)
+{
+	if (ipu_vbk_hash_initialized)
+		return;
+
+	hash_init(HASH_NAME);
+	ipu_vbk_hash_initialized = 1;
+}
+
+static int ipu_vbk_hash_add(struct ipu4_virtio_be_priv *entry)
+{
+	if (!ipu_vbk_hash_initialized) {
+		pr_err("RNG hash table not initialized!\n");
+		return -1;
+	}
+
+	hash_add(HASH_NAME, &entry->node, virtio_dev_client_id(&entry->dev));
+	return 0;
+}
+
+static struct ipu4_virtio_be_priv *ipu_vbk_hash_find(int client_id)
+{
+	struct ipu4_virtio_be_priv *entry;
+	int bkt;
+
+	if (!ipu_vbk_hash_initialized) {
+		pr_err("RNG hash table not initialized!\n");
+		return NULL;
+	}
+
+	hash_for_each(HASH_NAME, bkt, entry, node)
+		if (virtio_dev_client_id(&entry->dev) == client_id)
+			return entry;
+
+	pr_err("Not found item matching client_id!\n");
+	return NULL;
+}
+
+static int ipu_vbk_hash_del(int client_id)
+{
+	struct ipu4_virtio_be_priv *entry;
+	int bkt;
+
+	if (!ipu_vbk_hash_initialized) {
+		pr_err("RNG hash table not initialized!\n");
+		return -1;
+	}
+
+	hash_for_each(HASH_NAME, bkt, entry, node)
+		if (virtio_dev_client_id(&entry->dev) == client_id) {
+			hash_del(&entry->node);
+			return 0;
+		}
+
+	pr_err("%s failed, not found matching client_id!\n",
+	       __func__);
+	return -1;
+}
+
+static int ipu_vbk_hash_del_all(void)
+{
+	struct ipu4_virtio_be_priv *entry;
+	int bkt;
+
+	if (!ipu_vbk_hash_initialized) {
+		pr_err("RNG hash table not initialized!\n");
+		return -1;
+	}
+
+	hash_for_each(HASH_NAME, bkt, entry, node)
+		hash_del(&entry->node);
+
+	return 0;
+}
+
+static void handle_vq_kick(struct ipu4_virtio_be_priv *priv, int vq_idx)
+{
+	struct iovec iov;
+	struct ipu4_virtio_be_priv *be;
+	struct virtio_vq_info *vq;
+	struct ipu4_virtio_req *req = NULL;
+	int len;
+	int ret;
+	uint16_t idx;
+
+	pr_debug("%s: vq_idx %d\n", __func__, vq_idx);
+
+	be = priv;
+
+	if (!be) {
+		pr_err("rng is NULL! Cannot proceed!\n");
+		return;
+	}
+
+	vq = &(be->vqs[vq_idx]);
+
+	while (virtio_vq_has_descs(vq)) {
+		virtio_vq_getchain(vq, &idx, &iov, 1, NULL);
+
+		/* device specific operations, for example: */
+		pr_debug("iov base %p len %lx\n", iov.iov_base, iov.iov_len);
+
+		if (iov.iov_len != sizeof(struct ipu4_virtio_req)) {
+			if (iov.iov_len == sizeof(int)) {
+					*((int *)iov.iov_base) = 1;
+					len = iov.iov_len;
+					printk(KERN_NOTICE "IPU VBK handle kick from vmid:%d\n", 1);
+			} else {
+					len = 0;
+					printk(KERN_WARNING "received request with wrong size");
+					printk(KERN_WARNING "%zu != %zu\n",
+							iov.iov_len,
+							sizeof(struct ipu4_virtio_req));
+			}
+
+			pr_debug("vtrnd: vtrnd_notify(): %d\r\n", len);
+			virtio_vq_relchain(vq, idx, len);
+			continue;
+		}
+
+		req = (struct ipu4_virtio_req *)iov.iov_base;
+		ret = intel_ipu4_virtio_msg_parse(1, req);
+		len = iov.iov_len;
+
+		virtio_vq_relchain(vq, idx, len);
+	}
+	printk(KERN_NOTICE "IPU VBK data process on VQ Done\n");
+	virtio_vq_endchains(vq, 1);
+}
+
+static int handle_kick(int client_id, int req_cnt)
+{
+	int val = -1;
+	struct ipu4_virtio_be_priv *priv;
+
+	if (unlikely(req_cnt <= 0))
+		return -EINVAL;
+
+	printk(KERN_INFO "%s: IPU VBK handle kick!\n", __func__);
+
+	priv = ipu_vbk_hash_find(client_id);
+	if (priv == NULL) {
+		pr_err("%s: client %d not found!\n",
+				__func__, client_id);
+		return -EINVAL;
+	}
+
+	val = virtio_vq_index_get(&priv->dev, req_cnt);
+
+	if (val >= 0)
+		handle_vq_kick(priv, val);
+
+	return 0;
+}
+
+static int ipu_vbk_open(struct inode *inode, struct file *f)
+{
+	struct ipu4_virtio_be_priv *priv;
+	struct virtio_dev_info *dev;
+	struct virtio_vq_info *vqs;
+	int i;
+
+	priv = kcalloc(1, sizeof(struct ipu4_virtio_dev),
+		      GFP_KERNEL);
+
+	if (priv == NULL) {
+		pr_err("Failed to allocate memory for ipu4_virtio_be_priv!\n");
+		return -ENOMEM;
+	}
+
+	dev = &priv->dev;
+	strncpy(dev->name, "vbs_ipu", VBS_NAME_LEN);
+	dev->dev_notify = handle_kick;
+	vqs = (struct virtio_vq_info *)&priv->vqs;
+
+	for (i = 0; i < IPU_VIRTIO_QUEUE_MAX; i++) {
+		vqs[i].dev = dev;
+		/*
+		 * Currently relies on VHM to kick us,
+		 * thus vq_notify not used
+		 */
+		vqs[i].vq_notify = NULL;
+	}
+
+	/* link dev and vqs */
+	dev->vqs = vqs;
+
+	virtio_dev_init(dev, vqs, IPU_VIRTIO_QUEUE_MAX);
+
+	priv->pending_tx_req = kcalloc(1, sizeof(struct ipu4_virtio_req),
+								GFP_KERNEL);
+
+	mutex_init(&priv->lock);
+
+	f->private_data = priv;
+
+	/* init a hash table to maintain multi-connections */
+	ipu_vbk_hash_init();
+
+	return 0;
+}
+
+static int ipu_vbk_release(struct inode *inode, struct file *f)
+{
+	struct ipu4_virtio_be_priv *priv = f->private_data;
+	int i;
+
+	if (!priv)
+		pr_err("%s: UNLIKELY rng NULL!\n",
+		       __func__);
+
+	ipu_vbk_stop(priv);
+	ipu_vbk_flush(priv);
+	for (i = 0; i < IPU_VIRTIO_QUEUE_MAX; i++)
+		virtio_vq_reset(&(priv->vqs[i]));
+
+	/* device specific release */
+	ipu_vbk_reset(priv);
+
+	pr_debug("ipu_vbk_connection cnt is %d\n",
+			ipu_vbk_connection_cnt);
+
+	if (priv && ipu_vbk_connection_cnt--)
+		ipu_vbk_hash_del(virtio_dev_client_id(&priv->dev));
+	if (!ipu_vbk_connection_cnt) {
+		pr_debug("ipu4_virtio_be_priv remove all hash entries\n");
+		ipu_vbk_hash_del_all();
+	}
+
+	kfree(priv);
+
+	pr_debug("%s done\n", __func__);
+	return 0;
+}
+
+static long ipu_vbk_ioctl(struct file *f, unsigned int ioctl,
+			    unsigned long arg)
+{
+	struct ipu4_virtio_be_priv *priv = f->private_data;
+	void __user *argp = (void __user *)arg;
+	/*u64 __user *featurep = argp;*/
+	/*u64 features;*/
+	int r;
+
+	switch (ioctl) {
+/*
+ *	case VHOST_GET_FEATURES:
+ *		features = VHOST_NET_FEATURES;
+ *		if (copy_to_user(featurep, &features, sizeof features))
+ *			return -EFAULT;
+ *		return 0;
+ *	case VHOST_SET_FEATURES:
+ *		if (copy_from_user(&features, featurep, sizeof features))
+ *			return -EFAULT;
+ *		if (features & ~VHOST_NET_FEATURES)
+ *			return -EOPNOTSUPP;
+ *		return vhost_net_set_features(n, features);
+ */
+	case VBS_SET_VQ:
+		/*
+		 * we handle this here because we want to register VHM client
+		 * after handling VBS_K_SET_VQ request
+		 */
+		pr_debug("VBS_K_SET_VQ ioctl:\n");
+		r = virtio_vqs_ioctl(&priv->dev, ioctl, argp);
+		if (r == -ENOIOCTLCMD) {
+			pr_err("VBS_K_SET_VQ: virtio_vqs_ioctl failed!\n");
+			return -EFAULT;
+		}
+		/* Register VHM client */
+		if (virtio_dev_register(&priv->dev) < 0) {
+			pr_err("failed to register VHM client!\n");
+			return -EFAULT;
+		}
+		/* Added to local hash table */
+		if (ipu_vbk_hash_add(priv) < 0) {
+			pr_err("failed to add to hashtable!\n");
+			return -EFAULT;
+		}
+		/* Increment counter */
+		ipu_vbk_connection_cnt++;
+		return r;
+	default:
+		/*mutex_lock(&n->dev.mutex);*/
+		pr_debug("VBS_K generic ioctls!\n");
+		r = virtio_dev_ioctl(&priv->dev, ioctl, argp);
+		if (r == -ENOIOCTLCMD)
+			r = virtio_vqs_ioctl(&priv->dev, ioctl, argp);
+		else
+			ipu_vbk_flush(priv);
+		/*mutex_unlock(&n->dev.mutex);*/
+		return r;
+	}
+}
+
+/* device specific function to cleanup itself */
+static void ipu_vbk_reset(struct ipu4_virtio_be_priv *rng)
+{
+}
+
+/* device specific function */
+static void ipu_vbk_stop(struct ipu4_virtio_be_priv *rng)
+{
+	virtio_dev_deregister(&rng->dev);
+}
+
+/* device specific function */
+static void ipu_vbk_flush(struct ipu4_virtio_be_priv *rng)
+{
+}
+
+#ifdef RUNTIME_CTRL
+/* device specific function */
+static int ipu_vbk_enable_vq(struct ipu4_virtio_be_priv *rng,
+			     struct virtio_vq_info *vq)
+{
+	return 0;
+}
+
+/* device specific function */
+static void ipu_vbk_disable_vq(struct ipu4_virtio_be_priv *rng,
+			       struct virtio_vq_info *vq)
+{
+}
+
+/* device specific function */
+static void ipu_vbk_stop_vq(struct ipu4_virtio_be_priv *rng,
+			      struct virtio_vq_info *vq)
+{
+}
+
+/* device specific function */
+static void ipu_vbk_flush_vq(struct ipu4_virtio_be_priv *rng, int index)
+{
+}
+
+/* Set feature bits in kernel side device */
+static int ipu_vbk_set_features(struct ipu4_virtio_be_priv *rng, u64 features)
+{
+	return 0;
+}
+#endif
+
+static const struct file_operations vbs_fops = {
+	.owner          = THIS_MODULE,
+	.release        = ipu_vbk_release,
+	.unlocked_ioctl = ipu_vbk_ioctl,
+	.open           = ipu_vbk_open,
+	.llseek		= noop_llseek,
+};
+
+static struct miscdevice vbs_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "vbs_ipu",
+	.fops = &vbs_fops,
+};
+
+static int ipu_vbk_init(void)
+{
+	return misc_register(&vbs_misc);
+}
+module_init(ipu_vbk_init);
+
+static void ipu_vbk_exit(void)
+{
+	misc_deregister(&vbs_misc);
+}
+module_exit(ipu_vbk_exit);
+
+MODULE_VERSION("0.1");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("IPU4 virtio driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c
new file mode 100644
index 0000000..9653bb8f
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c
@@ -0,0 +1,201 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/syscalls.h>
+
+#include "intel-ipu4-virtio-bridge.h"
+
+int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
+{
+	int ret = 0;
+
+	if (!req) {
+			printk(KERN_ERR "request is NULL\n");
+			return -EINVAL;
+		}
+	if ((req->cmd < IPU4_CMD_DEVICE_OPEN) ||
+			(req->cmd >= IPU4_CMD_GET_N)) {
+			printk(KERN_ERR "invalid command\n");
+			return -EINVAL;
+	}
+	switch (req->cmd) {
+	case IPU4_CMD_DEVICE_OPEN:
+			/*
+			 * Open video device node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			printk(KERN_INFO "DEVICE_OPEN: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			req->stat = IPU4_REQ_PROCESSED;
+			break;
+	case IPU4_CMD_DEVICE_CLOSE:
+			/*
+			 * Close video device node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_STREAM_ON:
+			/* Start Stream
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_STREAM_OFF:
+			/* Stop Stream
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_GET_BUF:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
+			 * op3 - Number of planes
+			 * op4 - Buffer ID
+			 * op5 - Length of Buffer
+			 */
+			break;
+	case IPU4_CMD_PUT_BUF:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
+			 */
+			break;
+	case IPU4_CMD_SET_FORMAT:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Width
+			 * op3 - Height
+			 * op4 - Pixel Format
+			 * op5 - Field
+			 * op6 - Colorspace
+			 * op7 - Size of Image
+			 * op8 - Number of planes
+			 * op9 - flags
+			 */
+			printk(KERN_INFO "VBS SET_FMT: virtual_dev_id:%d actual_fd:%d\n", req->op[2], req->op[3]);
+			req->stat = IPU4_REQ_PROCESSED;
+			break;
+	case IPU4_CMD_ENUM_NODES:
+			break;
+	case IPU4_CMD_ENUM_LINKS:
+			break;
+	case IPU4_CMD_SETUP_PIPE:
+			break;
+	case IPU4_CMD_SET_FRAMEFMT:
+			break;
+	case IPU4_CMD_GET_FRAMEFMT:
+			break;
+	case IPU4_CMD_GET_SUPPORTED_FRAMEFMT:
+			break;
+	case IPU4_CMD_SET_SELECTION:
+			break;
+	case IPU4_CMD_GET_SELECTION:
+			break;
+	default:
+			return -EINVAL;
+		}
+
+	return ret;
+}
+
+void intel_ipu4_virtio_create_req(struct ipu4_virtio_req *req,
+			     enum intel_ipu4_virtio_command cmd, int *op)
+{
+	int i;
+
+	req->stat = IPU4_REQ_NOT_RESPONDED;
+	req->cmd = cmd;
+
+	switch (cmd) {
+	case IPU4_CMD_DEVICE_OPEN:
+			/* Open video device node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			for (i = 0; i < 2; i++)
+				req->op[i] = op[i];
+			break;
+	case IPU4_CMD_DEVICE_CLOSE:
+			/* Close video device node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_STREAM_ON:
+			/* Start Stream
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_STREAM_OFF:
+			/* Stop Stream
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			break;
+	case IPU4_CMD_GET_BUF:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
+			 * op3 - Number of planes
+			 * op4 - Buffer ID
+			 * op5 - Length of Buffer
+			 */
+			break;
+	case IPU4_CMD_PUT_BUF:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
+			 */
+			break;
+	case IPU4_CMD_SET_FORMAT:
+			/* Set Format of a given video node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 * op2 - Width
+			 * op3 - Height
+			 * op4 - Pixel Format
+			 * op5 - Field
+			 * op6 - Colorspace
+			 * op7 - Size of Image
+			 * op8 - Number of planes
+			 * op9 - flags
+			 */
+			for (i = 0; i < 10; i++)
+				req->op[i] = op[i];
+			break;
+	case IPU4_CMD_ENUM_NODES:
+			break;
+	case IPU4_CMD_ENUM_LINKS:
+			break;
+	case IPU4_CMD_SETUP_PIPE:
+			break;
+	case IPU4_CMD_SET_FRAMEFMT:
+			break;
+	case IPU4_CMD_GET_FRAMEFMT:
+			break;
+	case IPU4_CMD_GET_SUPPORTED_FRAMEFMT:
+			break;
+	case IPU4_CMD_SET_SELECTION:
+			break;
+	case IPU4_CMD_GET_SELECTION:
+			break;
+	default:
+			return;
+	}
+}
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h
new file mode 100644
index 0000000..f3fc29f
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __IPU4_VIRTIO_BE_BRIDGE__
+#define __IPU4_VIRTIO_BE_BRIDGE__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+
+#include "intel-ipu4-virtio-common.h"
+
+int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req);
+
+void intel_ipu4_virtio_create_req(struct ipu4_virtio_req *req,
+			     enum intel_ipu4_virtio_command cmd, int *op);
+
+int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req);
+
+
+#endif
+
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.c
new file mode 100644
index 0000000..17b0f06
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/cdev.h>
+#include <linux/hashtable.h>
+
+#include "intel-ipu4-virtio-common.h"
+
+DECLARE_HASHTABLE(ipu4_virtio_fe_hash, MAX_ENTRY_FE);
+
+void ipu4_virtio_fe_table_init(void)
+{
+	hash_init(ipu4_virtio_fe_hash);
+}
+
+int ipu4_virtio_fe_add(struct ipu4_virtio_fe_info *fe_info)
+{
+	struct ipu4_virtio_fe_info_entry *info_entry;
+
+	info_entry = kmalloc(sizeof(*info_entry), GFP_KERNEL);
+
+	if (!info_entry)
+		return -ENOMEM;
+
+	info_entry->info = fe_info;
+
+	hash_add(ipu4_virtio_fe_hash, &info_entry->node,
+		info_entry->info->client_id);
+
+	return 0;
+}
+
+struct ipu4_virtio_fe_info *ipu4_virtio_fe_find(int client_id)
+{
+	struct ipu4_virtio_fe_info_entry *info_entry;
+	int bkt;
+
+	hash_for_each(ipu4_virtio_fe_hash, bkt, info_entry, node)
+		if (info_entry->info->client_id == client_id)
+			return info_entry->info;
+
+	return NULL;
+}
+
+struct ipu4_virtio_fe_info *ipu4_virtio_fe_find_by_vmid(int vmid)
+{
+	struct ipu4_virtio_fe_info_entry *info_entry;
+	int bkt;
+
+	hash_for_each(ipu4_virtio_fe_hash, bkt, info_entry, node)
+		if (info_entry->info->vmid == vmid)
+			return info_entry->info;
+
+	return NULL;
+}
+
+int ipu4_virtio_fe_remove(int client_id)
+{
+	struct ipu4_virtio_fe_info_entry *info_entry;
+	int bkt;
+
+	hash_for_each(ipu4_virtio_fe_hash, bkt, info_entry, node)
+		if (info_entry->info->client_id == client_id) {
+			hash_del(&info_entry->node);
+			kfree(info_entry);
+			return 0;
+		}
+
+	return -ENOENT;
+}
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
new file mode 100644
index 0000000..f389dc8
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
@@ -0,0 +1,119 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __IPU4_VIRTIO_COMMON_H__
+#define __IPU4_VIRTIO_COMMON_H__
+
+
+/*
+ * CWP uses physicall addresses for memory sharing,
+ * so size of one page ref will be 64-bits
+ */
+
+#define REFS_PER_PAGE (PAGE_SIZE/sizeof(u64))
+
+/* Defines size of requests circular buffer */
+#define REQ_RING_SIZE 128
+
+#define MAX_NUMBER_OF_OPERANDS 64
+
+#define MAX_ENTRY_FE 7
+
+struct ipu4_virtio_req {
+	unsigned int req_id;
+	unsigned int stat;
+	unsigned int cmd;
+	unsigned int op[MAX_NUMBER_OF_OPERANDS];
+};
+struct ipu4_virtio_resp {
+	unsigned int resp_id;
+	unsigned int stat;
+	unsigned int cmd;
+	unsigned int op[MAX_NUMBER_OF_OPERANDS];
+};
+struct ipu4_virtio_fe_info {
+	struct ipu4_virtio_be_priv *priv;
+	int client_id;
+	int vmid;
+	int max_vcpu;
+	struct vhm_request *req_buf;
+};
+
+struct ipu4_virtio_fe_info_entry {
+	struct ipu4_virtio_fe_info *info;
+	struct hlist_node node;
+};
+
+struct ipu4_bknd_ops {
+	/* backed initialization routine */
+	int (*init)(void);
+
+	/* backed cleanup routine */
+	void (*cleanup)(void);
+
+	/* retreiving id of current virtual machine */
+	int (*get_vm_id)(void);
+
+	int (*send_req)(int, struct ipu4_virtio_req *, int);
+};
+
+struct ipu4_virtio_priv {
+	/* VM(domain) id of current VM instance */
+	int domid;
+
+	/* backend ops - hypervisor specific */
+	struct ipu4_bknd_ops *bknd_ops;
+
+	/* flag that shows whether backend is initialized */
+	bool initialized;
+
+	/* device global lock */
+	/* TODO: might need a lock per resource (e.g. EXPORT LIST) */
+	struct mutex lock;
+};
+
+struct ipu4_virtio_dev {
+	struct device *dev;
+	struct ipu4_virtio_priv *priv;
+};
+
+enum intel_ipu4_virtio_command {
+	IPU4_CMD_DEVICE_OPEN = 0x1,
+	IPU4_CMD_DEVICE_CLOSE,
+	IPU4_CMD_STREAM_ON,
+	IPU4_CMD_STREAM_OFF,
+	IPU4_CMD_GET_BUF,
+	IPU4_CMD_PUT_BUF,
+	IPU4_CMD_SET_FORMAT,
+	IPU4_CMD_ENUM_NODES,
+	IPU4_CMD_ENUM_LINKS,
+	IPU4_CMD_SETUP_PIPE,
+	IPU4_CMD_SET_FRAMEFMT,
+	IPU4_CMD_GET_FRAMEFMT,
+	IPU4_CMD_GET_SUPPORTED_FRAMEFMT,
+	IPU4_CMD_SET_SELECTION,
+	IPU4_CMD_GET_SELECTION,
+	IPU4_CMD_GET_N
+};
+
+enum intel_ipu4_virtio_req_feedback {
+	IPU4_REQ_PROCESSED,
+	IPU4_REQ_NEEDS_FOLLOW_UP,
+	IPU4_REQ_ERROR,
+	IPU4_REQ_NOT_RESPONDED
+};
+extern struct ipu4_bknd_ops ipu4_virtio_bknd_ops;
+
+void ipu4_virtio_fe_table_init(void);
+
+int ipu4_virtio_fe_add(struct ipu4_virtio_fe_info *fe_info);
+
+int ipu4_virtio_remove_fe(int client_id);
+
+struct ipu4_virtio_fe_info *ipu4_virtio_fe_find(int client_id);
+
+struct ipu4_virtio_fe_info *ipu4_virtio_fe_find_by_vmid(int vmid);
+
+#endif
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c
new file mode 100644
index 0000000..09c1fb47
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/virtio.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+#include <linux/module.h>
+#include "intel-ipu4-virtio-common.h"
+
+static DEFINE_IDA(index_ida);
+
+struct ipu4_virtio_fe_priv {
+	struct virtqueue *vq;
+	struct completion have_data;
+	char name[25];
+	unsigned int data_avail;
+	int index;
+	bool busy;
+	int vmid;
+};
+
+/* Assuming there will be one FE instance per VM */
+static struct ipu4_virtio_fe_priv *ipu4_virtio_fe;
+
+static void ipu_virtio_fe_tx_done(struct virtqueue *vq)
+{
+	struct ipu4_virtio_fe_priv *priv = vq->vdev->priv;
+
+	/* We can get spurious callbacks, e.g. shared IRQs + virtio_pci. */
+	if (!virtqueue_get_buf(priv->vq, &priv->data_avail))
+		return;
+
+	complete(&priv->have_data);
+	printk(KERN_NOTICE "IPU FE:%s vmid:%d\n", __func__, priv->vmid);
+}
+
+/* The host will fill any buffer we give it with sweet, sweet randomness. */
+static void ipu_virtio_fe_register_buffer(struct ipu4_virtio_fe_priv *vi, void *buf, size_t size)
+{
+	struct scatterlist sg;
+
+	sg_init_one(&sg, buf, size);
+
+	/* There should always be room for one buffer. */
+	virtqueue_add_inbuf(vi->vq, &sg, 1, buf, GFP_KERNEL);
+
+	virtqueue_kick(vi->vq);
+}
+
+static int ipu_virtio_fe_probe_common(struct virtio_device *vdev)
+{
+	int err, index;
+	struct ipu4_virtio_fe_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct ipu4_virtio_fe_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->index = index = ida_simple_get(&index_ida, 0, 0, GFP_KERNEL);
+	if (index < 0) {
+		err = index;
+		goto err_ida;
+	}
+	sprintf(priv->name, "virtio_.%d", index);
+	init_completion(&priv->have_data);
+	priv->vmid = -1;
+	vdev->priv = priv;
+
+	/* We expect a single virtqueue. */
+	priv->vq = virtio_find_single_vq(vdev, ipu_virtio_fe_tx_done, "csi_input");
+	if (IS_ERR(priv->vq)) {
+		err = PTR_ERR(priv->vq);
+		goto err_find;
+	}
+	ipu4_virtio_fe = priv;
+
+	return 0;
+
+err_find:
+	ida_simple_remove(&index_ida, index);
+err_ida:
+	kfree(priv);
+	return err;
+}
+
+static void ipu_virtio_fe_remove_common(struct virtio_device *vdev)
+{
+	struct ipu4_virtio_fe_priv *priv = vdev->priv;
+
+	priv->data_avail = 0;
+	complete(&priv->have_data);
+	vdev->config->reset(vdev);
+	priv->busy = false;
+
+	vdev->config->del_vqs(vdev);
+	ida_simple_remove(&index_ida, priv->index);
+	kfree(priv);
+}
+static int ipu_virtio_fe_send_req(int vmid, struct ipu4_virtio_req *req,
+			      int wait)
+{
+	struct ipu4_virtio_fe_priv *priv = ipu4_virtio_fe;
+	struct ipu4_virtio_req *tx_req;
+	int ret = 0;
+	int timeout = 1000;
+	printk(KERN_NOTICE "IPU FE:%s\n", __func__);
+	if (priv == NULL) {
+		printk(KERN_ERR	"IPU Backend not connected\n");
+		return -ENOENT;
+	}
+
+	tx_req = kcalloc(1, sizeof(*tx_req), GFP_KERNEL);
+	if (!tx_req)
+		return -ENOMEM;
+
+	memcpy(tx_req, req, sizeof(*req));
+
+	ipu_virtio_fe_register_buffer(ipu4_virtio_fe, tx_req, sizeof(*tx_req));
+
+	if (wait) {
+		while (timeout--) {
+			if (tx_req->stat !=
+				IPU4_REQ_NOT_RESPONDED)
+				break;
+			usleep_range(100, 120);
+		}
+
+	if (timeout < 0)
+		return -EBUSY;
+	}
+
+	return ret;
+}
+static int ipu_virtio_fe_get_vmid(void)
+{
+	struct ipu4_virtio_fe_priv *priv = ipu4_virtio_fe;
+
+	if (ipu4_virtio_fe == NULL) {
+		printk(KERN_ERR	"IPU Backend not connected\n");
+		return -1;
+	}
+	return priv->vmid;
+}
+
+int ipu_virtio_fe_register(void)
+{
+	printk(KERN_NOTICE "IPU FE:%s\n", __func__);
+	return 0;
+}
+
+void ipu_virtio_fe_unregister(void)
+{
+	printk(KERN_NOTICE "IPU FE:%s\n", __func__);
+	return;
+}
+static int virt_probe(struct virtio_device *vdev)
+{
+	return ipu_virtio_fe_probe_common(vdev);
+}
+
+static void virt_remove(struct virtio_device *vdev)
+{
+	ipu_virtio_fe_remove_common(vdev);
+}
+
+static void virt_scan(struct virtio_device *vdev)
+{
+	struct ipu4_virtio_fe_priv *vi = (struct ipu4_virtio_fe_priv *)vdev->priv;
+	int timeout = 1000;
+
+	if (vi == NULL) {
+		printk(KERN_NOTICE "IPU No frontend private data\n");
+		return;
+	}
+	ipu_virtio_fe_register_buffer(vi, &vi->vmid, sizeof(vi->vmid));
+
+	while (timeout--) {
+		if (vi->vmid > 0)
+			break;
+		usleep_range(100, 120);
+	}
+	printk(KERN_NOTICE "IPU FE:%s vmid:%d\n", __func__, vi->vmid);
+
+	if (timeout < 0)
+		printk(KERN_ERR	"IPU Cannot query vmid\n");
+
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int virt_freeze(struct virtio_device *vdev)
+{
+	ipu_virtio_fe_remove_common(vdev);
+	return 0;
+}
+
+static int virt_restore(struct virtio_device *vdev)
+{
+	return ipu_virtio_fe_probe_common(vdev);
+}
+#endif
+
+static struct virtio_device_id id_table[] = {
+	{ VIRTIO_ID_IPU, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+struct ipu4_bknd_ops ipu4_virtio_bknd_ops = {
+	.init = ipu_virtio_fe_register,
+	.cleanup = ipu_virtio_fe_unregister,
+	.get_vm_id = ipu_virtio_fe_get_vmid,
+	.send_req = ipu_virtio_fe_send_req
+};
+
+static struct virtio_driver virtio_driver = {
+	.driver.name =	KBUILD_MODNAME,
+	.driver.owner =	THIS_MODULE,
+	.id_table =	id_table,
+	.probe =	virt_probe,
+	.remove =	virt_remove,
+	.scan =		virt_scan,
+#ifdef CONFIG_PM_SLEEP
+	.freeze =	virt_freeze,
+	.restore =	virt_restore,
+#endif
+};
+
+
+module_virtio_driver(virtio_driver);
+MODULE_DEVICE_TABLE(virtio, id_table);
+MODULE_DESCRIPTION("IPU4 virtio driver");
+MODULE_LICENSE("Dual BSD/GPL");
-- 
1.9.1

