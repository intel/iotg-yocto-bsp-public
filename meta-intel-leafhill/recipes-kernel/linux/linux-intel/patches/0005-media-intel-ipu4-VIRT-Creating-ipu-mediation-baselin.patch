From d63e51975bb75e74d5dfbefb5b8ce680f589266f Mon Sep 17 00:00:00 2001
From: "Yu, Ong Hock" <ong.hock.yu@intel.com>
Date: Fri, 1 Jun 2018 09:15:09 -0700
Subject: [PATCH 05/16] media: intel-ipu4: [VIRT] Creating ipu mediation
 baseline v0.1

Change-Id: I76e7ee54d9dc521374a605d488c48eb5f9221118
Signed-off-by: Yu, Ong Hock <ong.hock.yu@intel.com>
Signed-off-by: Bandi, Kushal <kushal.bandi@intel.com>
---
 drivers/media/pci/intel/virtio/Makefile.virt       |   6 +-
 .../pci/intel/virtio/intel-ipu4-para-virt-drv.c    | 495 +++++++++++++++++----
 ...rtio-bridge.c => intel-ipu4-virtio-be-bridge.c} | 230 +++++-----
 ...rtio-bridge.h => intel-ipu4-virtio-be-bridge.h} |   0
 .../intel/virtio/intel-ipu4-virtio-be-pipeline.c   | 212 +++++++++
 .../intel/virtio/intel-ipu4-virtio-be-pipeline.h   |  27 ++
 .../pci/intel/virtio/intel-ipu4-virtio-be-stream.c | 233 ++++++++++
 .../pci/intel/virtio/intel-ipu4-virtio-be-stream.h |  24 +
 .../media/pci/intel/virtio/intel-ipu4-virtio-be.c  |   2 +-
 .../pci/intel/virtio/intel-ipu4-virtio-common.h    |   4 +
 .../intel/virtio/intel-ipu4-virtio-fe-payload.c    |  52 +++
 .../intel/virtio/intel-ipu4-virtio-fe-payload.h    |  14 +
 .../intel/virtio/intel-ipu4-virtio-fe-pipeline.c   |  46 ++
 .../intel/virtio/intel-ipu4-virtio-fe-pipeline.h   |  19 +
 .../media/pci/intel/virtio/intel-ipu4-virtio-fe.c  |  24 +-
 15 files changed, 1162 insertions(+), 226 deletions(-)
 rename drivers/media/pci/intel/virtio/{intel-ipu4-virtio-bridge.c => intel-ipu4-virtio-be-bridge.c} (54%)
 rename drivers/media/pci/intel/virtio/{intel-ipu4-virtio-bridge.h => intel-ipu4-virtio-be-bridge.h} (100%)
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.h
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.c
 create mode 100644 drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.h

diff --git a/drivers/media/pci/intel/virtio/Makefile.virt b/drivers/media/pci/intel/virtio/Makefile.virt
index 07ece61..c3c30c4 100644
--- a/drivers/media/pci/intel/virtio/Makefile.virt
+++ b/drivers/media/pci/intel/virtio/Makefile.virt
@@ -5,12 +5,16 @@ endif
 TARGET_MODULE:=intel-ipu-virt-$(IPU_STEP)
 
 $(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-common.o
-$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-bridge.o
 
 
 ifdef CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-be-pipeline.o
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-be-bridge.o
 	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-be.o
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-be-stream.o
 else
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-fe-pipeline.o
+	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-fe-payload.o
 	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-virtio-fe.o
 	$(TARGET_MODULE)-objs += ../virtio/intel-ipu4-para-virt-drv.o
 endif
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
index 023a61a..b01a9e8 100644
--- a/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-para-virt-drv.c
@@ -14,18 +14,27 @@
 #include <linux/dma-buf.h>
 
 #include "intel-ipu4-virtio-common.h"
-#include "intel-ipu4-virtio-bridge.h"
 #include "intel-ipu4-para-virt-drv.h"
+#include "intel-ipu4-virtio-fe-pipeline.h"
+#include "intel-ipu4-virtio-fe-payload.h"
+#include "./ici/ici-isys-stream.h"
+#include "./ici/ici-isys-pipeline-device.h"
 
 
 #define MAX_STREAM_DEVICES 64
+#define MAX_PIPELINE_DEVICES 1
 
+static dev_t virt_pipeline_dev_t;
+static struct class *virt_pipeline_class;
+static struct ici_isys_pipeline_device *pipeline_dev;
 
 static dev_t virt_stream_dev_t;
 static struct class *virt_stream_class;
 static int virt_stream_devs_registered;
 static int stream_dev_init;
 
+static struct ipu4_virtio_ctx *g_fe_priv;
+
 static int get_userpages(struct device *dev,
 			struct ici_frame_plane *frame_plane,
 			struct ici_kframe_plane *kframe_plane)
@@ -484,14 +493,8 @@ static int virt_isys_set_format(struct file *file, void *fh,
 		return -ENOMEM;
 	op[0] = 0;
 	op[1] = 0;
-	op[2] = sf->ffmt.width;
-	op[3] =	sf->ffmt.height;
-	op[4] = sf->ffmt.pixelformat;
-	op[5] = sf->ffmt.field;
-	op[6] = sf->ffmt.colorspace;
-	op[7] = 0;
-	op[8] = 0;
-	op[9] = 0;
+
+	req->payload = virt_to_phys(sf);
 
 	intel_ipu4_virtio_create_req(req, IPU4_CMD_SET_FORMAT, &op[0]);
 
@@ -513,6 +516,23 @@ static int virt_isys_stream_on(struct file *file, void *fh)
 	struct ipu4_virtio_ctx *fe_ctx = vstream->ctx;
 	struct ipu4_virtio_req *req;
 	int rval = 0;
+	int op[10];
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	op[0] = vstream->virt_dev_id;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_STREAM_ON, &op[0]);
+
+	rval = fe_ctx->bknd_ops->send_req(fe_ctx->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
 
 	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
 	if (!req && !fe_ctx)
@@ -528,6 +548,23 @@ static int virt_isys_stream_off(struct file *file, void *fh)
 	struct ipu4_virtio_ctx *fe_ctx = vstream->ctx;
 	struct ipu4_virtio_req *req;
 	int rval = 0;
+	int op[10];
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	op[0] = vstream->virt_dev_id;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_STREAM_OFF, &op[0]);
+
+	rval = fe_ctx->bknd_ops->send_req(fe_ctx->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
 
 	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
 	if (!req && !fe_ctx)
@@ -596,23 +633,45 @@ static int virt_isys_putbuf(struct file *file, void *fh,
 	return rval;
 }
 
-static unsigned int stream_fop_poll(struct file *file,
-	struct poll_table_struct *poll)
+static unsigned int stream_fop_poll(struct file *file, struct ici_stream_device *dev)
 {
+	struct ipu4_virtio_req *req;
+	struct virtual_stream *vstream = dev_to_vstream(dev);
+	struct ipu4_virtio_ctx *fe_ctx = vstream->ctx;
 	int rval = 0;
+	int op[2];
+	printk(KERN_INFO "virt stream open\n");
+	get_device(&dev->dev);
 
-	return rval;
+	file->private_data = dev;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	op[0] = dev->virt_dev_id;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_POLL, &op[0]);
+
+	rval = fe_ctx->bknd_ops->send_req(fe_ctx->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
+
+	return req->func_ret;
 }
 
 static int virt_stream_fop_open(struct inode *inode, struct file *file)
 {
 	struct ici_stream_device *strm_dev = inode_to_intel_ipu_stream_device(inode);
 	struct ipu4_virtio_req *req;
-	struct test_payload *payload;
 	struct virtual_stream *vstream = dev_to_vstream(strm_dev);
 	struct ipu4_virtio_ctx *fe_ctx = vstream->ctx;
 	int rval = 0;
-	char name[256] = "payload_name";
 	int op[3];
 	printk(KERN_INFO "virtual stream open\n");
 	get_device(&strm_dev->dev);
@@ -628,22 +687,9 @@ static int virt_stream_fop_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	}
 
-	payload = kcalloc(1, sizeof(*payload), GFP_KERNEL);
-	if (!payload) {
-		printk(KERN_ERR "Req Payload failed\n");
-		return -ENOMEM;
-	}
-	payload->data1 = 1000;
-	payload->data2 = 1234567890;
-
-	strlcpy(payload->name, name, sizeof(name));
-	req->payload = virt_to_phys(payload);
-	printk(KERN_INFO "virt_stream_fop_open: payload guest_phy_addr: %lld\n", req->payload);
-
 	op[0] = vstream->virt_dev_id;
 	op[1] = 1;
 
-
 	intel_ipu4_virtio_create_req(req, IPU4_CMD_DEVICE_OPEN, &op[0]);
 
 	rval = fe_ctx->bknd_ops->send_req(fe_ctx->domid, req, true);
@@ -659,7 +705,33 @@ static int virt_stream_fop_open(struct inode *inode, struct file *file)
 
 static int virt_stream_fop_release(struct inode *inode, struct file *file)
 {
+	struct ici_stream_device *strm_dev = inode_to_intel_ipu_stream_device(inode);
+	struct ipu4_virtio_req *req;
+	struct virtual_stream *vstream = dev_to_vstream(strm_dev);
+	struct ipu4_virtio_ctx *fe_ctx = vstream->ctx;
 	int rval = 0;
+	int op[2];
+	printk(KERN_INFO "virt stream close\n");
+	put_device(&strm_dev->dev);
+
+	file->private_data = strm_dev;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	op[0] = strm_dev->virt_dev_id;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_DEVICE_CLOSE, &op[0]);
+
+	rval = fe_ctx->bknd_ops->send_req(fe_ctx->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to close virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
 
 	return rval;
 }
@@ -672,7 +744,7 @@ static unsigned int virt_stream_fop_poll(struct file *file,
 
 	printk(KERN_NOTICE "virt_stream_fop_poll for:%s\n", as->name);
 
-	res = stream_fop_poll(file, poll);
+	res = stream_fop_poll(file, as);
 
 	res = POLLIN;
 
@@ -685,59 +757,67 @@ static long virt_stream_ioctl(struct file *file,
 				unsigned int ioctl_cmd,
 				unsigned long ioctl_arg)
 {
-	union {
+	union isys_ioctl_cmd_args {
 			struct ici_frame_info frame_info;
 			struct ici_stream_format sf;
-		} isys_ioctl_cmd_args;
-		int err = 0;
-		struct ici_stream_device *dev = file->private_data;
-		void __user *up = (void __user *)ioctl_arg;
-
-		bool copy = (ioctl_cmd != ICI_IOC_STREAM_ON &&
-				ioctl_cmd != ICI_IOC_STREAM_OFF);
-
-		if (copy) {
-			if (_IOC_SIZE(ioctl_cmd) > sizeof(isys_ioctl_cmd_args))
-				return -ENOTTY;
-
-			if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
-				err = copy_from_user(&isys_ioctl_cmd_args, up,
-					_IOC_SIZE(ioctl_cmd));
-				if (err)
-					return -EFAULT;
+	};
+	int err = 0;
+	union isys_ioctl_cmd_args *data = NULL;
+	struct ici_stream_device *dev = file->private_data;
+	void __user *up = (void __user *)ioctl_arg;
+
+	bool copy = (ioctl_cmd != ICI_IOC_STREAM_ON &&
+			ioctl_cmd != ICI_IOC_STREAM_OFF);
+
+	if (copy) {
+		if (_IOC_SIZE(ioctl_cmd) > sizeof(union isys_ioctl_cmd_args))
+			return -ENOTTY;
+
+		data = (union isys_ioctl_cmd_args *) kzalloc(sizeof(union isys_ioctl_cmd_args), GFP_KERNEL);
+		if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
+			err = copy_from_user(data, up,
+				_IOC_SIZE(ioctl_cmd));
+			if (err) {
+				kfree(data);
+				return -EFAULT;
 			}
 		}
+	}
 
-		mutex_lock(dev->mutex);
-
-		switch (ioctl_cmd) {
-		case ICI_IOC_STREAM_ON:
-			printk(KERN_INFO "IPU FE IOCTL STREAM_ON\n");
-			err = virt_isys_stream_on(file, dev);
-			break;
-		case ICI_IOC_STREAM_OFF:
-			printk(KERN_INFO "IPU FE IOCTL STREAM_OFF\n");
-			err = virt_isys_stream_off(file, dev);
-			break;
-		case ICI_IOC_GET_BUF:
-			printk(KERN_INFO "IPU FE IOCTL GET_BUF\n");
-			err = virt_isys_getbuf(file, dev, &isys_ioctl_cmd_args.frame_info);
-			break;
-		case ICI_IOC_PUT_BUF:
-			printk(KERN_INFO "IPU FE IOCTL PUT_BUF\n");
-			err = virt_isys_putbuf(file, dev, &isys_ioctl_cmd_args.frame_info);
-			break;
-		case ICI_IOC_SET_FORMAT:
-			printk(KERN_INFO "IPU FE IOCTL SET_FORMAT\n");
-			err = virt_isys_set_format(file, dev, &isys_ioctl_cmd_args.sf);
-			break;
+	mutex_lock(dev->mutex);
 
-		default:
-			err = -ENOTTY;
-			break;
-		}
+	switch (ioctl_cmd) {
+	case ICI_IOC_STREAM_ON:
+		printk(KERN_INFO "IPU FE IOCTL STREAM_ON\n");
+		err = virt_isys_stream_on(file, dev);
+		break;
+	case ICI_IOC_STREAM_OFF:
+		printk(KERN_INFO "IPU FE IOCTL STREAM_OFF\n");
+		err = virt_isys_stream_off(file, dev);
+		break;
+	case ICI_IOC_GET_BUF:
+		printk(KERN_INFO "IPU FE IOCTL GET_BUF\n");
+		err = virt_isys_getbuf(file, dev, &data->frame_info);
+		break;
+	case ICI_IOC_PUT_BUF:
+		printk(KERN_INFO "IPU FE IOCTL PUT_BUF\n");
+		err = virt_isys_putbuf(file, dev, &data->frame_info);
+		break;
+	case ICI_IOC_SET_FORMAT:
+		printk(KERN_INFO "IPU FE IOCTL SET_FORMAT\n");
+		err = virt_isys_set_format(file, dev, &data->sf);
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(dev->mutex);
 
-		mutex_unlock(dev->mutex);
+	if (copy) {
+		err = copy_to_user(up, data, _IOC_SIZE(ioctl_cmd));
+		kfree(data);
+	}
 	return 0;
 }
 
@@ -859,6 +939,253 @@ static void virt_ici_stream_exit(void)
 	printk(KERN_INFO "virt_ici stream device unregistered\n");
 }
 
+static int virt_pipeline_fop_open(struct inode *inode, struct file *file)
+{
+	struct ici_isys_pipeline_device *dev = inode_to_ici_isys_pipeline_device(inode);
+	struct ipu4_virtio_req *req;
+	int rval = 0;
+	int op[2];
+	printk(KERN_INFO "virt pipeline open\n");
+	get_device(&dev->dev);
+
+	file->private_data = dev;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	op[0] = dev->minor;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_PIPELINE_OPEN, &op[0]);
+
+	rval = g_fe_priv->bknd_ops->send_req(g_fe_priv->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to open virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
+
+	return rval;
+}
+
+static int virt_pipeline_fop_release(struct inode *inode, struct file *file)
+{
+	int rval = 0;
+	int op[2];
+	struct ipu4_virtio_req *req;
+
+	struct ici_isys_pipeline_device *pipe_dev =
+	    inode_to_ici_isys_pipeline_device(inode);
+
+	put_device(&pipe_dev->dev);
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	op[0] = pipe_dev->minor;
+	op[1] = 0;
+
+	intel_ipu4_virtio_create_req(req, IPU4_CMD_PIPELINE_CLOSE, &op[0]);
+
+	rval = g_fe_priv->bknd_ops->send_req(g_fe_priv->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to close virtual device\n");
+		kfree(req);
+		return rval;
+	}
+	kfree(req);
+
+	return rval;
+}
+
+static long virt_pipeline_ioctl(struct file *file, unsigned int ioctl_cmd,
+			       unsigned long ioctl_arg)
+{
+	union isys_ioctl_cmd_args {
+		struct ici_node_desc node_desc;
+		struct ici_link_desc link;
+		struct ici_pad_framefmt pad_prop;
+		struct ici_pad_supported_format_desc
+			format_desc;
+		struct ici_links_query links_query;
+		struct ici_pad_selection pad_sel;
+	};
+	int err = 0;
+	union isys_ioctl_cmd_args *data = NULL;
+	void __user *up = (void __user *)ioctl_arg;
+	struct ici_isys_pipeline_device *dev = file->private_data;
+
+	if (_IOC_SIZE(ioctl_cmd) > sizeof(union isys_ioctl_cmd_args))
+		return -ENOTTY;
+
+	data = (union isys_ioctl_cmd_args *) kzalloc(sizeof(union isys_ioctl_cmd_args), GFP_KERNEL);
+	if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
+		err = copy_from_user(data, up,
+			_IOC_SIZE(ioctl_cmd));
+		if (err) {
+			kfree(data);
+			return -EFAULT;
+		}
+	}
+	mutex_lock(&dev->mutex);
+	switch (ioctl_cmd) {
+	case ICI_IOC_ENUM_NODES:
+		//printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_ENUM_NODES\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->node_desc, IPU4_CMD_ENUM_NODES);
+		break;
+	case ICI_IOC_ENUM_LINKS:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_ENUM_LINKS\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->links_query, IPU4_CMD_ENUM_LINKS);
+		break;
+	case ICI_IOC_SETUP_PIPE:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_SETUP_PIPE\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->link, IPU4_CMD_SETUP_PIPE);
+		break;
+	case ICI_IOC_SET_FRAMEFMT:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_SET_FRAMEFMT\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->pad_prop, IPU4_CMD_SET_FRAMEFMT);
+		break;
+	case ICI_IOC_GET_FRAMEFMT:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_GET_FRAMEFMT\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->pad_prop, IPU4_CMD_GET_FRAMEFMT);
+		break;
+	case ICI_IOC_GET_SUPPORTED_FRAMEFMT:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_GET_SUPPORTED_FRAMEFMT\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->format_desc, IPU4_CMD_GET_SUPPORTED_FRAMEFMT);
+		break;
+	case ICI_IOC_SET_SELECTION:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_SET_SELECTION\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->pad_sel, IPU4_CMD_SET_SELECTION);
+		break;
+	case ICI_IOC_GET_SELECTION:
+		printk(KERN_INFO "virt_pipeline_ioctl: ICI_IOC_GET_SELECTION\n");
+		err = process_pipeline(file, g_fe_priv,
+			(void *)&data->pad_sel, IPU4_CMD_GET_SELECTION);
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(&dev->mutex);
+	if (err < 0) {
+		kfree(data);
+		return err;
+	}
+
+	if (_IOC_DIR(ioctl_cmd) & _IOC_READ) {
+		err = copy_to_user(up, data,
+			_IOC_SIZE(ioctl_cmd));
+		if (err) {
+			kfree(data);
+			return -EFAULT;
+		}
+	}
+	kfree(data);
+
+	return 0;
+}
+
+static const struct file_operations virt_pipeline_fops = {
+	.owner = THIS_MODULE,
+	.open = virt_pipeline_fop_open,
+	.unlocked_ioctl = virt_pipeline_ioctl,
+//#ifdef CONFIG_COMPAT
+//	.compat_ioctl = virt_pipeline_ioctl32,
+//#endif
+	.release = virt_pipeline_fop_release,
+};
+
+static int virt_FE_init(void)
+{
+	int rval;
+
+	g_fe_priv = kcalloc(1, sizeof(struct ipu4_virtio_ctx),
+					      GFP_KERNEL);
+
+	if (!g_fe_priv)
+		return -ENOMEM;
+
+	g_fe_priv->bknd_ops = &ipu4_virtio_bknd_ops;
+
+	if (g_fe_priv->bknd_ops->init) {
+		rval = g_fe_priv->bknd_ops->init();
+		if (rval < 0) {
+			printk(KERN_NOTICE
+				"failed to initialize backend.\n");
+			return rval;
+		}
+	}
+
+	g_fe_priv->domid = g_fe_priv->bknd_ops->get_vm_id();
+	printk("FE registered with domid:%d\n", g_fe_priv->domid);
+
+	return 0;
+}
+
+static int virt_ici_pipeline_init(void)
+{
+	int rval;
+	printk(KERN_NOTICE "Initializing pipeline\n");
+	virt_pipeline_dev_t = MKDEV(MAJOR_PIPELINE, 0);
+
+	rval = register_chrdev_region(virt_pipeline_dev_t,
+	MAX_PIPELINE_DEVICES, ICI_PIPELINE_DEVICE_NAME);
+	if (rval) {
+		printk(
+			KERN_WARNING "can't register virt_ici stream chrdev region (%d)\n",
+			rval);
+		return rval;
+	}
+
+	virt_pipeline_class = class_create(THIS_MODULE, ICI_PIPELINE_DEVICE_NAME);
+	if (IS_ERR(virt_pipeline_class)) {
+		unregister_chrdev_region(virt_pipeline_dev_t, MAX_PIPELINE_DEVICES);
+		printk(KERN_WARNING "Failed to register device class %s\n",
+				ICI_PIPELINE_DEVICE_NAME);
+		return PTR_ERR(virt_pipeline_class);
+	}
+
+	pipeline_dev = kzalloc(sizeof(*pipeline_dev), GFP_KERNEL);
+	if (!pipeline_dev)
+		return -ENOMEM;
+	pipeline_dev->minor = -1;
+	cdev_init(&pipeline_dev->cdev, &virt_pipeline_fops);
+	pipeline_dev->cdev.owner = virt_pipeline_fops.owner;
+
+	rval = cdev_add(&pipeline_dev->cdev, MKDEV(MAJOR_PIPELINE, MINOR_PIPELINE), 1);
+	if (rval) {
+			printk(KERN_WARNING "%s: failed to add cdevice\n", __func__);
+			return rval;
+	}
+
+	pipeline_dev->dev.class = virt_pipeline_class;
+	pipeline_dev->dev.devt = MKDEV(MAJOR_PIPELINE, MINOR_PIPELINE);
+	dev_set_name(&pipeline_dev->dev, "%s", ICI_PIPELINE_DEVICE_NAME);
+
+	rval = device_register(&pipeline_dev->dev);
+	if (rval < 0) {
+		printk(KERN_WARNING "%s: device_register failed\n", __func__);
+		cdev_del(&pipeline_dev->cdev);
+		return rval;
+	}
+	pipeline_dev->dev.release = base_device_release;
+	strlcpy(pipeline_dev->name, pipeline_dev->dev.kobj.name, sizeof(pipeline_dev->name));
+	pipeline_dev->minor = MINOR_PIPELINE;
+
+	return 0;
+}
+
 static int __init virt_ici_init(void)
 {
 	struct virtual_stream *vstream;
@@ -885,7 +1212,12 @@ static int __init virt_ici_init(void)
 		if (rval)
 			return rval;
 	}
-	return 0;
+
+	rval = virt_ici_pipeline_init();
+	if (rval)
+		return rval;
+	rval = virt_FE_init();
+	return rval;
 
 init_fail:
 	mutex_destroy(&vstream->mutex);
@@ -893,9 +1225,22 @@ static int __init virt_ici_init(void)
 	return rval;
 }
 
+static void virt_ici_pipeline_exit(void)
+{
+	class_unregister(virt_pipeline_class);
+	unregister_chrdev_region(virt_pipeline_dev_t, MAX_PIPELINE_DEVICES);
+	if (pipeline_dev)
+		kfree((void *)pipeline_dev);
+	if (g_fe_priv)
+		kfree((void *)g_fe_priv);
+
+	printk(KERN_INFO "virt_ici pipeline device unregistered\n");
+}
+
 static void __exit virt_ici_exit(void)
 {
 	virt_ici_stream_exit();
+	virt_ici_pipeline_exit();
 }
 
 module_init(virt_ici_init);
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-bridge.c
similarity index 54%
rename from drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c
rename to drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-bridge.c
index 57144d8..21a5b50 100644
--- a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.c
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-bridge.c
@@ -12,14 +12,14 @@
 #include <linux/syscalls.h>
 #include <linux/pagemap.h>
 
-#include "intel-ipu4-virtio-bridge.h"
+#include "intel-ipu4-virtio-be-bridge.h"
 #include "./ici/ici-isys-frame-buf.h"
+#include "intel-ipu4-virtio-be-pipeline.h"
+#include "intel-ipu4-virtio-be-stream.h"
 
-#ifdef CONFIG_VIDEO_INTEL_IPU_VIRTIO_BE
 int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 {
 	int ret = 0;
-	struct test_payload *payload;
 	struct ici_frame_buf_wrapper *shared_buf;
 	int k, i = 0;
 	void *pageaddr;
@@ -36,23 +36,31 @@ int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 			return -EINVAL;
 	}
 	switch (req->cmd) {
+	case IPU4_CMD_POLL:
+			/*
+			 * Open video device node
+			 * op0 - virtual device node number
+			 * op1 - Actual device fd. By default set to 0
+			 */
+			printk(KERN_INFO "POLL: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			ret = process_poll(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
+			break;
 	case IPU4_CMD_DEVICE_OPEN:
-
 			/*
 			 * Open video device node
 			 * op0 - virtual device node number
 			 * op1 - Actual device fd. By default set to 0
 			 */
-			printk(KERN_INFO "DEVICE_OPEN: payload guest_phy_addr: %lld\n", req->payload);
-			payload = (struct test_payload *)map_guest_phys(domid, req->payload, PAGE_SIZE);
-			if (!payload)
-				printk("BE DATA is NULL\n");
-			else{
-					printk(KERN_INFO "DEVICE_OPEN: virtual_dev_id:%d actual_fd:%d payload_data1:%d payload_data2:%ld name:%s\n",
-					req->op[0], req->op[1], payload->data1, payload->data2, payload->name);
-				/*printk(KERN_INFO "DEVICE_OPEN: virtual_dev_id:%d actual_fd:%d\n",req->op[0],req->op[1]);*/
-			}
-			req->stat = IPU4_REQ_PROCESSED;
+			printk(KERN_INFO "DEVICE_OPEN: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			ret = process_device_open(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_DEVICE_CLOSE:
 			/*
@@ -60,18 +68,36 @@ int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 			 * op0 - virtual device node number
 			 * op1 - Actual device fd. By default set to 0
 			 */
+			printk(KERN_INFO "DEVICE_CLOSE: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			ret = process_device_close(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_STREAM_ON:
 			/* Start Stream
 			 * op0 - virtual device node number
 			 * op1 - Actual device fd. By default set to 0
 			 */
+			printk(KERN_INFO "STREAM ON: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			ret = process_stream_on(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_STREAM_OFF:
 			/* Stop Stream
 			 * op0 - virtual device node number
 			 * op1 - Actual device fd. By default set to 0
 			 */
+			printk(KERN_INFO "STREAM OFF: virtual_dev_id:%d actual_fd:%d\n", req->op[0], req->op[1]);
+			ret = process_stream_off(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_GET_BUF:
 			/* Set Format of a given video node
@@ -130,8 +156,8 @@ int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 
 			 req->stat = IPU4_REQ_PROCESSED;
 
-				break;
-		case IPU4_CMD_PUT_BUF:
+			break;
+	case IPU4_CMD_PUT_BUF:
 			/* Set Format of a given video node
 			 * op0 - virtual device node number
 			 * op1 - Actual device fd. By default set to 0
@@ -139,36 +165,81 @@ int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 			 */
 			break;
 	case IPU4_CMD_SET_FORMAT:
-			/* Set Format of a given video node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 * op2 - Width
-			 * op3 - Height
-			 * op4 - Pixel Format
-			 * op5 - Field
-			 * op6 - Colorspace
-			 * op7 - Size of Image
-			 * op8 - Number of planes
-			 * op9 - flags
-			 */
-			printk(KERN_INFO "VBS SET_FMT: Width:%d Height:%d\n", req->op[2], req->op[3]);
-			req->stat = IPU4_REQ_PROCESSED;
+			ret = process_set_format(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
+			break;
+	case IPU4_CMD_PIPELINE_OPEN:
+			ret = process_pipeline_open(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
+			break;
+	case IPU4_CMD_PIPELINE_CLOSE:
+			ret = process_pipeline_close(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_ENUM_NODES:
+			ret = process_enum_nodes(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_ENUM_LINKS:
+			ret = process_enum_links(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_SETUP_PIPE:
+			ret = process_setup_pipe(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_SET_FRAMEFMT:
+			ret = process_set_framefmt(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_GET_FRAMEFMT:
+			ret = process_get_framefmt(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_GET_SUPPORTED_FRAMEFMT:
+			ret = process_get_supported_framefmt(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_SET_SELECTION:
+			ret = process_pad_set_sel(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	case IPU4_CMD_GET_SELECTION:
+			ret = process_pad_get_sel(domid, req);
+			if (ret)
+				req->stat = IPU4_REQ_ERROR;
+			else
+				req->stat = IPU4_REQ_PROCESSED;
 			break;
 	default:
 			return -EINVAL;
@@ -176,102 +247,3 @@ int intel_ipu4_virtio_msg_parse(int domid, struct ipu4_virtio_req *req)
 
 	return ret;
 }
-#endif
-void intel_ipu4_virtio_create_req(struct ipu4_virtio_req *req,
-			     enum intel_ipu4_virtio_command cmd, int *op)
-{
-	int i;
-
-	req->stat = IPU4_REQ_NOT_RESPONDED;
-	req->cmd = cmd;
-
-	switch (cmd) {
-	case IPU4_CMD_DEVICE_OPEN:
-			/* Open video device node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 */
-			for (i = 0; i < 2; i++) {
-				req->op[i] = op[i];
-			}
-			break;
-	case IPU4_CMD_DEVICE_CLOSE:
-			/* Close video device node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 */
-			break;
-	case IPU4_CMD_STREAM_ON:
-			/* Start Stream
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 */
-			for (i = 0; i < 2; i++) {
-					req->op[i] = op[i];
-			}
-			break;
-	case IPU4_CMD_STREAM_OFF:
-			/* Stop Stream
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 */
-			for (i = 0; i < 2; i++) {
-				req->op[i] = op[i];
-			}
-			break;
-	case IPU4_CMD_GET_BUF:
-			/* Set Format of a given video node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
-			 * op3 - Number of planes
-			 * op4 - Buffer ID
-			 * op5 - Length of Buffer
-			 */
-			for (i = 0; i < 3; i++) {
-				req->op[i] = op[i];
-			}
-			break;
-		case IPU4_CMD_PUT_BUF:
-			/* Set Format of a given video node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 * op2 - Memory Type 1: USER_PTR 2: DMA_PTR
-			 */
-			break;
-	case IPU4_CMD_SET_FORMAT:
-			/* Set Format of a given video node
-			 * op0 - virtual device node number
-			 * op1 - Actual device fd. By default set to 0
-			 * op2 - Width
-			 * op3 - Height
-			 * op4 - Pixel Format
-			 * op5 - Field
-			 * op6 - Colorspace
-			 * op7 - Size of Image
-			 * op8 - Number of planes
-			 * op9 - flags
-			 */
-			for (i = 0; i < 10; i++)
-				req->op[i] = op[i];
-			break;
-	case IPU4_CMD_ENUM_NODES:
-			break;
-	case IPU4_CMD_ENUM_LINKS:
-			break;
-	case IPU4_CMD_SETUP_PIPE:
-			break;
-	case IPU4_CMD_SET_FRAMEFMT:
-			break;
-	case IPU4_CMD_GET_FRAMEFMT:
-			break;
-	case IPU4_CMD_GET_SUPPORTED_FRAMEFMT:
-			break;
-	case IPU4_CMD_SET_SELECTION:
-			break;
-	case IPU4_CMD_GET_SELECTION:
-			break;
-	default:
-			return;
-	}
-}
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-bridge.h
similarity index 100%
rename from drivers/media/pci/intel/virtio/intel-ipu4-virtio-bridge.h
rename to drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-bridge.h
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.c
new file mode 100644
index 0000000..43c6b5e
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.c
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/file.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+
+#include <media/ici.h>
+#include <linux/vhm/acrn_vhm_mm.h>
+#include "intel-ipu4-virtio-be-pipeline.h"
+#include "./ici/ici-isys-pipeline.h"
+#include "./ici/ici-isys-pipeline-device.h"
+
+static struct file *pipeline;
+static int guestID = -1;
+
+int process_pipeline_open(int domid, struct ipu4_virtio_req *req)
+{
+	if (guestID != -1 && guestID != domid) {
+		printk(KERN_ERR "process_device_open: pipeline device already opened by other guest! %d %d", guestID, domid);
+		return -1;
+	}
+
+	printk(KERN_INFO "process_device_open: /dev/intel_pipeline");
+	pipeline = filp_open("/dev/intel_pipeline", O_RDWR | O_NONBLOCK, 0);
+	guestID = domid;
+
+	return 0;
+}
+
+int process_pipeline_close(int domid, struct ipu4_virtio_req *req)
+{
+	printk(KERN_INFO "process_device_close: %d", req->op[0]);
+
+	filp_close(pipeline, 0);
+	guestID = -1;
+
+	return 0;
+}
+
+int process_enum_nodes(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_node_desc *host_virt;
+
+	printk(KERN_INFO "process_enum_nodes");
+
+	host_virt = (struct ici_node_desc *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_enum_nodes: NULL host_virt");
+		return 0;
+	}
+	printk(KERN_INFO "process_enum_nodes: pipeline_enum_nodes: before");
+	err = dev->pipeline_ioctl_ops->pipeline_enum_nodes(pipeline, dev, host_virt);
+	printk(KERN_INFO "process_enum_nodes: pipeline_enum_nodes: after");
+
+	return err;
+}
+
+int process_enum_links(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_links_query *host_virt;
+
+	printk(KERN_INFO "process_enum_links");
+
+	host_virt = (struct ici_links_query *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_enum_links: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pipeline_enum_links(pipeline, dev, host_virt);
+
+	return err;
+}
+int process_get_supported_framefmt(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_pad_supported_format_desc *host_virt;
+
+	printk(KERN_INFO "process_get_supported_framefmt");
+
+	host_virt = (struct ici_pad_supported_format_desc *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_get_supported_framefmt: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pad_get_supported_format(pipeline, dev, host_virt);
+
+	return err;
+}
+
+int process_set_framefmt(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_pad_framefmt *host_virt;
+
+	printk(KERN_INFO "process_set_framefmt");
+
+	host_virt = (struct ici_pad_framefmt *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_set_framefmt: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pad_set_ffmt(pipeline, dev, host_virt);
+
+	return err;
+}
+
+int process_get_framefmt(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_pad_framefmt *host_virt;
+
+	printk(KERN_INFO "process_get_framefmt");
+
+	host_virt = (struct ici_pad_framefmt *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_get_framefmt: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pad_get_ffmt(pipeline, dev, host_virt);
+
+	return err;
+}
+
+int process_setup_pipe(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_link_desc *host_virt;
+
+	printk(KERN_INFO "process_setup_pipe");
+
+	host_virt = (struct ici_link_desc *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_setup_pipe: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pipeline_setup_pipe(pipeline, dev, host_virt);
+
+	return err;
+}
+
+int process_pad_set_sel(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_pad_selection *host_virt;
+
+	printk(KERN_INFO "process_pad_set_sel");
+
+	host_virt = (struct ici_pad_selection *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_pad_set_sel: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pad_set_sel(pipeline, dev, host_virt);
+
+	return err;
+}
+
+int process_pad_get_sel(int domid, struct ipu4_virtio_req *req)
+{
+	int err = 0;
+	struct ici_isys_pipeline_device *dev = pipeline->private_data;
+	struct ici_pad_selection *host_virt;
+
+	printk(KERN_INFO "process_pad_get_sel");
+
+	host_virt = (struct ici_pad_selection *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_pad_get_sel: NULL host_virt");
+		return 0;
+	}
+	err = dev->pipeline_ioctl_ops->pad_get_sel(pipeline, dev, host_virt);
+
+	return err;
+}
+
+/*
+	union isys_ioctl_cmd_args {
+		struct ici_node_desc node_desc;
+		struct ici_link_desc link;
+		struct ici_pad_framefmt pad_prop;
+		struct ici_pad_supported_format_desc
+			format_desc;
+		struct ici_links_query links_query;
+		struct ici_pad_selection pad_sel;
+	};
+
+	.pipeline_setup_pipe = ici_setup_link,
+	.pipeline_enum_nodes = pipeline_enum_nodes,
+	.pipeline_enum_links = pipeline_enum_links,
+	.pad_set_ffmt = ici_pipeline_set_ffmt,
+	.pad_get_ffmt = ici_pipeline_get_ffmt,
+	.pad_get_supported_format =
+		ici_pipeline_get_supported_format,
+	.pad_set_sel = ici_pipeline_set_sel,
+	.pad_get_sel = ici_pipeline_get_sel,
+
+*/
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.h
new file mode 100644
index 0000000..df65e88
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-pipeline.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __IPU4_VIRTIO_BE_PIPELINE__
+#define __IPU4_VIRTIO_BE_PIPELINE__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+
+#include "intel-ipu4-virtio-common.h"
+
+int process_pipeline_open(int domid, struct ipu4_virtio_req *req);
+int process_pipeline_close(int domid, struct ipu4_virtio_req *req);
+int process_enum_nodes(int domid, struct ipu4_virtio_req *req);
+int process_enum_links(int domid, struct ipu4_virtio_req *req);
+int process_get_supported_framefmt(int domid, struct ipu4_virtio_req *req);
+int process_set_framefmt(int domid, struct ipu4_virtio_req *req);
+int process_get_framefmt(int domid, struct ipu4_virtio_req *req);
+int process_pad_set_sel(int domid, struct ipu4_virtio_req *req);
+int process_pad_get_sel(int domid, struct ipu4_virtio_req *req);
+int process_setup_pipe(int domid, struct ipu4_virtio_req *req);
+
+#endif
+
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.c
new file mode 100644
index 0000000..6373546
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/file.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+
+#include <linux/hashtable.h>
+#include <media/ici.h>
+#include <linux/vhm/acrn_vhm_mm.h>
+#include "./ici/ici-isys-stream-device.h"
+#include "./ici/ici-isys-stream.h"
+#include "./ici/ici-isys-frame-buf.h"
+#include "intel-ipu4-virtio-be-stream.h"
+
+#define MAX_SIZE 6 // max 2^6
+
+#define dev_to_stream(dev) \
+	container_of(dev, struct ici_isys_stream, strm_dev)
+
+DECLARE_HASHTABLE(STREAM_NODE_HASH, MAX_SIZE);
+static bool hash_initialised;
+
+struct stream_node {
+	int client_id;
+	struct file *f;
+	struct hlist_node node;
+};
+
+int process_device_open(int domid, struct ipu4_virtio_req *req)
+{
+	char node_name[25];
+	struct stream_node *sn = NULL;
+
+	if (!hash_initialised) {
+		hash_init(STREAM_NODE_HASH);
+		hash_initialised = true;
+	}
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0])
+		if (sn != NULL) {
+			if (sn->client_id != domid) {
+				printk(KERN_ERR "process_device_open: stream device %d already opened by other guest!", sn->client_id);
+				return -EBUSY;
+			}
+			printk(KERN_INFO "process_device_open: stream device %d already opened by client %d", req->op[0], domid);
+			return 0;
+		}
+
+	sprintf(node_name, "/dev/intel_stream%d", req->op[0]);
+	printk(KERN_INFO "process_device_open: %s", node_name);
+	sn = kzalloc(sizeof(struct stream_node), GFP_KERNEL);
+	sn->f = filp_open(node_name, O_RDWR | O_NONBLOCK, 0);
+	sn->client_id = domid;
+
+	hash_add(STREAM_NODE_HASH, &sn->node, req->op[0]);
+
+	return 0;
+}
+
+int process_device_close(int domid, struct ipu4_virtio_req *req)
+{
+	struct stream_node *sn = NULL;
+	if (!hash_initialised)
+		return 0; //no node has been opened, do nothing
+
+	printk(KERN_INFO "process_device_close: %d", req->op[0]);
+
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0])
+	if (sn != NULL) {
+		printk(KERN_INFO "process_device_close: %d closed", req->op[0]);
+		hash_del(&sn->node);
+		filp_close(sn->f, 0);
+		kfree(sn);
+	}
+
+	return 0;
+}
+
+int process_set_format(int domid, struct ipu4_virtio_req *req)
+{
+	struct stream_node *sn = NULL;
+	struct ici_stream_format *host_virt;
+	struct ici_stream_device *strm_dev;
+	int err;
+
+	printk(KERN_INFO "process_set_format: %d %d", hash_initialised, req->op[0]);
+
+	if (!hash_initialised)
+		return -1;
+
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0]) {
+		printk(KERN_INFO "process_set_format: sn %d %p", req->op[0], sn);
+		if (sn != NULL) {
+			printk(KERN_INFO "process_set_format: node %d %p", req->op[0], sn);
+			break;
+		}
+	}
+	if (sn == NULL) {
+		printk(KERN_ERR "process_set_format: NULL sn\n");
+		return 0;
+	}
+
+	if (sn->f == NULL) {
+		printk(KERN_ERR "process_set_format: NULL sn->f\n");
+		return 0;
+	}
+	strm_dev = sn->f->private_data;
+
+	host_virt = (struct ici_stream_format *)map_guest_phys(domid, req->payload, PAGE_SIZE);
+	if (host_virt == NULL) {
+		printk(KERN_ERR "process_set_format: NULL host_virt");
+		return 0;
+	}
+
+	err = strm_dev->ipu_ioctl_ops->ici_set_format(sn->f, strm_dev, host_virt);
+
+	if (err)
+		printk(KERN_ERR "intel_ipu4_pvirt: internal set fmt failed\n");
+
+	return 0;
+}
+
+int process_poll(int domid, struct ipu4_virtio_req *req)
+{
+	struct stream_node *sn = NULL;
+	struct ici_isys_stream *as;
+	struct ici_isys_frame_buf_list *buf_list;
+	int ret;
+	printk(KERN_INFO "process_poll: %d", hash_initialised);
+
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0]) {
+		if (sn != NULL) {
+			printk(KERN_INFO "process_poll: node %d %p", req->op[0], sn);
+			break;
+		}
+	}
+
+	as = dev_to_stream(sn->f->private_data);
+
+	buf_list = &as->buf_list;
+
+	ret = wait_event_interruptible_timeout(buf_list->wait,
+						!list_empty(&buf_list->putbuf_list),
+						100); //1 jiffy -> 10ms
+
+	printk(KERN_INFO "process_poll: ret: %d", ret);
+	if (ret == 1)
+		req->func_ret = POLLIN;
+	else if (ret == 0)
+		req->func_ret = 0;//POLLHUP;
+	else
+		req->func_ret = -1;//POLLERR;
+
+	return 0;
+}
+
+int process_stream_on(int domid, struct ipu4_virtio_req *req)
+{
+	struct stream_node *sn = NULL;
+	struct ici_stream_device *strm_dev;
+	int err;
+
+	printk(KERN_INFO "process_stream_on: %d %d", hash_initialised, req->op[0]);
+
+	if (!hash_initialised)
+		return -1;
+
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0]) {
+		printk(KERN_INFO "process_stream_on: sn %d %p", req->op[0], sn);
+		if (sn != NULL) {
+			printk(KERN_INFO "process_stream_on: node %d %p", req->op[0], sn);
+			break;
+		}
+	}
+	if (sn == NULL) {
+		printk(KERN_ERR "process_stream_on: NULL sn\n");
+		return 0;
+	}
+
+	if (sn->f == NULL) {
+		printk(KERN_ERR "process_stream_on: NULL sn->f\n");
+		return 0;
+	}
+	strm_dev = sn->f->private_data;
+
+	err = strm_dev->ipu_ioctl_ops->ici_stream_on(sn->f, strm_dev);
+
+	if (err)
+		printk(KERN_ERR "process_stream_on: stream on failed\n");
+
+	return 0;
+}
+
+int process_stream_off(int domid, struct ipu4_virtio_req *req)
+{
+	struct stream_node *sn = NULL;
+	struct ici_stream_device *strm_dev;
+	int err;
+
+	printk(KERN_INFO "process_stream_off: %d %d", hash_initialised, req->op[0]);
+
+	if (!hash_initialised)
+		return -1;
+
+	hash_for_each_possible(STREAM_NODE_HASH, sn, node, req->op[0]) {
+		printk(KERN_INFO "process_stream_off: sn %d %p", req->op[0], sn);
+		if (sn != NULL) {
+			printk(KERN_INFO "process_stream_off: node %d %p", req->op[0], sn);
+			break;
+		}
+	}
+	if (sn == NULL) {
+		printk(KERN_ERR "process_stream_off: NULL sn\n");
+		return 0;
+	}
+
+	if (sn->f == NULL) {
+		printk(KERN_ERR "process_stream_off: NULL sn->f\n");
+		return 0;
+	}
+	strm_dev = sn->f->private_data;
+
+	err = strm_dev->ipu_ioctl_ops->ici_stream_off(sn->f, strm_dev);
+
+	if (err)
+		printk(KERN_ERR "process_stream_off: stream off failed\n");
+
+	return 0;
+}
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.h
new file mode 100644
index 0000000..4915ab0
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be-stream.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __IPU4_VIRTIO_BE_STREAM__
+#define __IPU4_VIRTIO_BE_STREAM__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+
+#include "intel-ipu4-virtio-common.h"
+
+int process_set_format(int domid, struct ipu4_virtio_req *req);
+int process_device_open(int domid, struct ipu4_virtio_req *req);
+int process_device_close(int domid, struct ipu4_virtio_req *req);
+int process_poll(int domid, struct ipu4_virtio_req *req);
+int process_stream_on(int domid, struct ipu4_virtio_req *req);
+int process_stream_off(int domid, struct ipu4_virtio_req *req);
+
+
+#endif
+
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
index a7912b4..609d7b8 100644
--- a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-be.c
@@ -16,7 +16,7 @@
 #include <linux/hashtable.h>
 
 #include "intel-ipu4-virtio-common.h"
-#include "intel-ipu4-virtio-bridge.h"
+#include "intel-ipu4-virtio-be-bridge.h"
 
 enum {
 	IPU_VIRTIO_RX_QUEUE = 0,
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
index 15c5f63..3098b47 100644
--- a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-common.h
@@ -25,6 +25,7 @@ struct ipu4_virtio_req {
 	unsigned int req_id;
 	unsigned int stat;
 	unsigned int cmd;
+	unsigned int func_ret;
 	unsigned int op[MAX_NUMBER_OF_OPERANDS];
 	u64 payload;
 };
@@ -99,6 +100,9 @@ enum intel_ipu4_virtio_command {
 	IPU4_CMD_GET_SUPPORTED_FRAMEFMT,
 	IPU4_CMD_SET_SELECTION,
 	IPU4_CMD_GET_SELECTION,
+	IPU4_CMD_POLL,
+	IPU4_CMD_PIPELINE_OPEN,
+	IPU4_CMD_PIPELINE_CLOSE,
 	IPU4_CMD_GET_N
 };
 
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.c
new file mode 100644
index 0000000..d878224
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.c
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/syscalls.h>
+
+#include "intel-ipu4-virtio-common.h"
+#include "intel-ipu4-virtio-fe-payload.h"
+
+void intel_ipu4_virtio_create_req(struct ipu4_virtio_req *req,
+			     enum intel_ipu4_virtio_command cmd, int *op)
+{
+	int i;
+
+	req->stat = IPU4_REQ_NOT_RESPONDED;
+	req->cmd = cmd;
+
+	switch (cmd) {
+	case IPU4_CMD_POLL:
+	case IPU4_CMD_DEVICE_OPEN:
+	case IPU4_CMD_DEVICE_CLOSE:
+	case IPU4_CMD_STREAM_ON:
+	case IPU4_CMD_STREAM_OFF:
+	case IPU4_CMD_GET_BUF:
+	case IPU4_CMD_PUT_BUF:
+	case IPU4_CMD_SET_FORMAT:
+	case IPU4_CMD_ENUM_NODES:
+	case IPU4_CMD_ENUM_LINKS:
+	case IPU4_CMD_SETUP_PIPE:
+	case IPU4_CMD_SET_FRAMEFMT:
+	case IPU4_CMD_GET_FRAMEFMT:
+	case IPU4_CMD_GET_SUPPORTED_FRAMEFMT:
+	case IPU4_CMD_SET_SELECTION:
+	case IPU4_CMD_GET_SELECTION:
+		/* Open video device node
+		 * op0 - virtual device node number
+		 * op1 - Actual device fd. By default set to 0
+		 */
+		for (i = 0; i < 2; i++)
+			req->op[i] = op[i];
+		break;
+	default:
+		return;
+	}
+}
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.h
new file mode 100644
index 0000000..173c31a
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-payload.h
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __IPU4_VIRTIO_FE_PAYLOAD__
+#define __IPU4_VIRTIO_FE_PAYLOAD__
+
+#include "intel-ipu4-virtio-common.h"
+
+void intel_ipu4_virtio_create_req(struct ipu4_virtio_req *req,
+			     enum intel_ipu4_virtio_command cmd, int *op);
+
+#endif
\ No newline at end of file
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.c
new file mode 100644
index 0000000..0706c18
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.c
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/ioctl.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include "intel-ipu4-virtio-fe-payload.h"
+#include "intel-ipu4-virtio-fe-pipeline.h"
+
+int process_pipeline(struct file *file,
+						struct ipu4_virtio_ctx *fe_priv,
+						void *data,
+						int cmd)
+{
+	struct ipu4_virtio_req *req;
+	int rval = 0;
+	int op[10];
+
+	op[0] = 0;
+	op[1] = 0;
+
+	req = kcalloc(1, sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	req->payload = virt_to_phys(data);
+
+	intel_ipu4_virtio_create_req(req, cmd, &op[0]);
+
+	rval = fe_priv->bknd_ops->send_req(fe_priv->domid, req, true);
+	if (rval) {
+		printk(KERN_ERR "Failed to send request to BE\n");
+		kfree(req);
+		return rval;
+	}
+
+	kfree(req);
+
+	return rval;
+}
+
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.h b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.h
new file mode 100644
index 0000000..d1fbe10
--- /dev/null
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe-pipeline.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef IPU4_VIRTIO_FE_PIPELINE_H
+#define IPU4_VIRTIO_FE_PIPELINE_H
+
+#include <media/ici.h>
+
+#include "virtio/intel-ipu4-virtio-common.h"
+
+int process_pipeline(struct file *file,
+						struct ipu4_virtio_ctx *fe_priv,
+						void *data,
+						int cmd);
+
+
+#endif
diff --git a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c
index e4bb5e9..57cbb47 100644
--- a/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c
+++ b/drivers/media/pci/intel/virtio/intel-ipu4-virtio-fe.c
@@ -103,37 +103,21 @@ static void ipu_virtio_fe_remove_common(struct virtio_device *vdev)
 	ida_simple_remove(&index_ida, priv->index);
 	kfree(priv);
 }
+
 static int ipu_virtio_fe_send_req(int vmid, struct ipu4_virtio_req *req,
 			      int wait)
 {
 	struct ipu4_virtio_uos *priv = ipu4_virtio_fe;
-	struct ipu4_virtio_req *tx_req;
 	int ret = 0;
-	int timeout = 1000;
 	printk(KERN_NOTICE "IPU FE:%s\n", __func__);
 	if (priv == NULL) {
 		printk(KERN_ERR	"IPU Backend not connected\n");
 		return -ENOENT;
 	}
 
-	tx_req = kcalloc(1, sizeof(*tx_req), GFP_KERNEL);
-	if (!tx_req)
-		return -ENOMEM;
-
-	memcpy(tx_req, req, sizeof(*req));
-
-	ipu_virtio_fe_register_buffer(ipu4_virtio_fe, tx_req, sizeof(*tx_req));
-
-	if (wait) {
-		while (timeout--) {
-			if (tx_req->stat !=	IPU4_REQ_NOT_RESPONDED)
-				break;
-			usleep_range(100, 120);
-		}
-
-	if (timeout < 0)
-		return -EBUSY;
-	}
+	init_completion(&priv->have_data);
+	ipu_virtio_fe_register_buffer(ipu4_virtio_fe, req, sizeof(*req));
+	wait_for_completion(&priv->have_data);
 
 	return ret;
 }
-- 
1.9.1

